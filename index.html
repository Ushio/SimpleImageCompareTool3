<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
    <title>SimpleImageCompareTool3</title>

    <script src="jquery-3.3.1.min.js"></script>
    <script src="jquery.event.move.js"></script>
    <script src="jquery.knob.js"></script>

    <link rel="stylesheet" href="jquery-ui.min.css">
    <script src="jquery-ui.min.js"></script>

    <script src="GlslCanvas.js"></script>
    <script src="FileSaver.js"></script>
    <script src="paste.js"></script>
    <script src="exrapi_compiled.js"></script>
    
    <link rel="stylesheet" href="huebee.css">
    <script src="huebee.pkgd.js"></script>

    <link rel="stylesheet" href="check.css">
    <link rel="stylesheet" href="slider.css">
    <link rel="stylesheet" href="combo.css">

    <script src="Chart.js"></script>

    <script src="uPlot.iife.js"></script>
    <link rel="stylesheet" href="uPlot.min.css">

    <style>
        .dragover {
            background:rgb(193, 225, 255);
        }
        .boxspan {
            display: inline-block;
            width: 100%;
            text-align: center;
            line-height:50px;
        }

        /* disable pixel filter */
        .disablePixelFilter {
            image-rendering: optimizeSpeed;             /* Older versions of FF          */
            image-rendering: -moz-crisp-edges;          /* FF 6.0+                       */
            image-rendering: -webkit-optimize-contrast; /* Safari                        */
            image-rendering: -o-crisp-edges;            /* OS X & Windows Opera (12.02+) */
            image-rendering: pixelated;                 /* Awesome future-browsers       */
            -ms-interpolation-mode: nearest-neighbor;   /* IE                            */
        }

        .ui-dialog-titlebar{
            padding: 0.3rem !important;
            font-size: 0.75rem;
        }
    </style>
</head>

<body>
<div style="margin: 10px;">
    <div style="width: 100%; display: flex; ">
        <div id="drop-zoneL" style="height: 50px; width: 100%; border: thin solid #acacac;  border-radius: 10px;"><span class="boxspan">Left Image (Please drop your image here)</span></div>
        <div style="width: 20px;"></div>
        <div id="drop-zoneR" style="height: 50px; width: 100%; border: thin solid #acacac;  border-radius: 10px;"><span class="boxspan">Right Image (Please drop your image here)</span></div>
    </div>
</div>

<div style="display: flex; justify-content: center; align-items: baseline;" id="glcontainer">
    <canvas id="glcanvas" style="max-width:100%; height:auto;" class="disablePixelFilter">
</div>

<div style="display: flex; justify-content: center; align-items: baseline; position: absolute; left: 0px; top: 0px; z-index: 10;" id="uicontainer">
    <canvas id="uicanvas" style="max-width:100%; height:auto;">
</div>

<style>
.ui_container > div {
    flex-basis: 160px;
    height: 160px;
    margin: 5px;
    padding: 12px;
    background: #ffffff;
    border-radius: 10px;
    box-shadow:0px 1px 0px 1px #d5d5d5;
}
</style>
<div style="margin:20px; padding:10px; background: #ececec; border-radius: 10px;">
    <div style="display: flex; flex-wrap: wrap; " class="ui_container">
        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Direction</div>
            <div id="dial_container">
                <input type="text" value="0" class="direction_dial" data-width="100" data-displayInput=false data-thickness=.5 data-cursor=true>
            </div>
            <select id="fixed_direction" name="fixed_direction">
                <option value="">Free Direction</option>
                <option value="↘">↘</option>
                <option value="↗">↗</option>
                <option value="↖">↖</option>
                <option value="↙">↙</option>
            </select>
        </div>
        
        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Border</div>
            <div style="text-align: center;" id="borderlabel">2 px</div>
            <div style="height: 25px"></div> <!--  margin -->
            <input type="range" value="2" min="0" max="32" step="1" id="border" class="slider">
        </div>

        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Border Color</div>
            <div style="height: 25px"></div> <!--  margin -->
            <input class="border_color" value="#000000" style="width:130px"/>
        </div>

        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Labels</div>
            <div style="height: 25px"></div> <!--  margin -->
            <input value="" style="width:130px" id="Label_L_override"/>
            <div style="height: 10px"></div> <!--  margin -->
            <input value="" style="width:130px" id="Label_R_override"/>
        </div>

        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Font Size</div>
            <div style="text-align: center;" id="fontsizelabel">20 px</div>
            <div style="height: 25px"></div> <!--  margin -->
            <input type="range" value="20" min="0" max="100" step="1" id="fontsize" class="slider">
        </div>

        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Font Color</div>
            <div style="height: 25px"></div> <!--  margin -->
            <input class="font_color" value="#FF0000" style="width:130px"/>
        </div>

        <div style="display: flex; flex-direction:column; align-items: center;" id="fperror">
            <div style="text-align: center;">Floating Point Error</div>
            <div style="height: 15px"></div> <!--  margin -->
            <div style="text-align: center; font-size: 14px;">NaN</div>
            <input class="Nan_Color" value="#FF0000" style="width:130px"/>
            <div style="height: 10px"></div> <!--  margin -->
            <div style="text-align: center; font-size: 14px;">Infinity</div>
            <div style="height: 5px"></div> <!--  margin -->
            <input class="Inf_Color" value="#FF00FF" style="width:130px"/>
        </div>

        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Diff Mode</div>
            <div style="height: 20px"></div> <!--  margin -->
            <div class="onoffswitch">
                <input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="diffmode" onchange="didChangeDiffMode(this.checked)">
                <label class="onoffswitch-label" for="diffmode"></label>
            </div>
            <div style="height: 20px"></div> <!--  margin -->
            <div style="text-align: center; opacity:0.3;" id="diffscalelabel">100 %</div>
            <input type="range" value="100" min="100" max="500" step="1" id="diffscale" style="opacity:0.3;" class="slider">
        </div>

        <style>
            .PasteAreaL:focus-within {
                background:rgb(91, 88, 255);
            }
            .PasteAreaR:focus-within {
                background:rgb(91, 88, 255);
            }
        </style>
        <div style="display: flex; flex-direction:column; align-items: center; ">
            <div style="text-align: center;">Click and Paste L↓</div>
            <div class="PasteAreaL" style="height: 80%; width: 90%; border: thin solid #acacac;"></div>
        </div>
        <div style="display: flex; flex-direction:column; align-items: center; ">
            <div style="text-align: center;">Click and Paste R↓</div>
            <div class="PasteAreaR" style="height: 80%; width: 90%; border: thin solid #acacac;"></div>
        </div>
        
        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Loupe</div>
            <div style="height: 10px"></div> <!--  margin -->
            <div class="onoffswitch">
                <input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="loupeMode" onchange="didChangeLoupeMode(this.checked)">
                <label class="onoffswitch-label" for="loupeMode"></label>
            </div>
            <div style="height: 10px"></div> <!--  margin -->
            <div style="text-align: center; opacity:0.3;" id="loupeSizeLabel">150 px</div>
            <div style="height: 5px"></div> <!--  margin -->
            <input type="range" value="150" min="10" max="500" step="10" id="loupeSize" style="opacity:0.3;" class="slider">
            <div style="height: 10px"></div> <!--  margin -->
            <div style="text-align: center; opacity:0.3;" id="loupeScaleLabel">200 %</div>
            <div style="height: 5px"></div> <!--  margin -->
            <input type="range" value="200" min="100" max="500" step="10" id="loupeScale" style="opacity:0.3;" class="slider">
        </div>

        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Post Process</div>
            <div style="height: 10px"></div> <!--  margin -->
            <div class="onoffswitch">
                <input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="PostProcess" onchange="didChangePostProcess(this.checked)">
                <label class="onoffswitch-label" for="PostProcess"></label>
            </div>
            <div style="height: 10px"></div> <!--  margin -->
            <div style="text-align: center; opacity:0.3;" id="postScaleLabel">100 %</div>
            <div style="height: 10px"></div> <!--  margin -->
            <input type="range" value="100" min="10" max="300" step="10" id="postScale" style="opacity:0.3;" class="slider">
            <div style="height: 22px"></div> <!--  margin -->
            <select id="GammaSelect" style="opacity:0.3;">
                <option value="1.0">Gamma 1.0</option>
                <option value="2.2" selected>Gamma 2.2</option>
                <option value="2.4">Gamma 2.4</option>
            </select>
        </div>

        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Slice Graph</div>
            <div style="height: 10px"></div> <!--  margin -->
            <button style="
                background: url('icSliceGraph.svg') no-repeat center;
                height: 100px;
                width: 100px;
                border: 2px solid #E8E8E8;
            " onclick="onSliceGraph()"></button>
        </div>

        <div style="display: flex; flex-direction:column; align-items: center;  margin-left: auto; background-image:url(gradient.png); background-size: 100% 23%; background-repeat: no-repeat;">
            <div style="text-align: center; opacity:0.3;" id="WelchLabel"> Welch (exr only)</div>
            <div style="height: 14px"></div> <!--  margin -->
            <button style="
                background: url('welch.svg') no-repeat center;
                height: 80px;
                width: 80px;
                color: white;
                opacity:0.3;
            " onclick="onWelch()" id="WelchButton"></button>
            <div style="height: 20px"></div> <!--  margin -->
            <input type="range" value="0" min="0" max="100" step="1" id="WelchSlider" style="opacity:0.3;" class="slider">
        </div>
        <div style="display: flex; flex-direction:column; align-items: center; flex-basis: 250px; height: 160px; display: none;" id="pUI">
            <canvas id="wcanvas" style="max-width:100%; height:auto; margin: -6px;"></canvas>
            <!-- background-color: aqua;  -->
        </div>
        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Save</div>
            <div style="height: 10px"></div> <!--  margin -->
            <button style="
                background: url('save.svg') no-repeat center;
                height: 100px;
                width: 100px;
                color: white;
            " onclick="onSave()"></button>
        </div>
    </div>
</div>

<a href="https://github.com/Ushio/SimpleImageCompareTool3">Github Repo</a>

<div hidden>
    <div id="sldialog" title="Slice Graph" style="padding: 0;margin:0">
        <!-- <div style="
        background-color: rgb(255, 0, 200);
        top: 0;
        left: 0;
        width: 100%;
        height: 50px;
        ">
        <canvas id="slcanvas" style="
            background-color: aqua;
            /* position: absolute; */
            top: 0;
            left: 0;
            /* width: 100%;
            height: 100%; */
        "> </canvas>
        </div> -->
    </div>
</div>

<details>
    <summary>Welch Notes</summary>
    <ul>
    <li>Violet is danger area. But all Violet is won't necessarily mean wrong.</li>
    <li>Uniform-distribution of p-value is good. but there are some exceptions on high match tile e.g. EnvMap. it could cause unbalanced distribution. </li>
    <li>You could capture pretty faint errors like this ( metallic parameter 0.00 vs 0.01 )</li>
    </ul>
    
    <img src="welch_example.png"></img>
</details>

<script>
'use strict';

// Vector
function add(a, b)
{
    return {
        x: a.x + b.x,
        y: a.y + b.y,
    };
}
function sub(a, b)
{
    return {
        x: a.x - b.x,
        y: a.y - b.y,
    };
}
function mulScalar(a, s)
{
    return {
        x: a.x * s,
        y: a.y * s,
    };
}
function dot(a, b)
{
    return a.x * b.x + a.y * b.y;
}
function lerp(a, b, amt)
{
    return a + (b - a) * amt;
}

const canvas = document.getElementById('glcanvas');
const glsl = new GlslCanvas(canvas, {preserveDrawingBuffer: true});

const uicanvas = document.getElementById('uicanvas');
const uictx = uicanvas.getContext('2d');
const compositecanvas = document.createElement('canvas');

function invokeRender() {
    glsl.forceRender = true;
    glsl.render();
    glsl.forceRender = false;
}

let L_filename = "L";
let R_filename = "R";

let angle = 0.0; // for label location

// be careful. this should point initial image size
canvas.width = 1200;
canvas.height = 722;

const HILIGHT_VALUE = 0.4;

// For welch
var floatImageWidth  = 0;
var floatImageHeight = 0;
var floatImageL = null;
var floatImageR = null;

// for Slice Graph. left to right and top to bottom order.
let imageLRaw = null;
let imageRRaw = null;

// relative to ui canvas. up positive.
let sliceVertices = [
    { x: 0.25, y: 0.5 },
    { x: 0.75, y: 0.5 },
];
const SLICE_VERTEX_RADIUS = 18;
const SLICE_MODE_NONE = 0;
const SLICE_MODE_DRAG = 1;
const SLICE_MODE_NEW  = 2;
const SLICE_MODE_DRAG_LINE  = 3;

let sliceVertexGrab = -1;
let isSliceGraphShowing = false;
let sliceMode = SLICE_MODE_NONE;

let grabbaseVertices = [
    { x: 0.25, y: 0.5 },
    { x: 0.75, y: 0.5 },
];
let grabbaseX = 0;
let grabbaseY = 0;

let focusSliceAMT = null;

// for flexible drop
let glu_directionX = 1;
let glu_directionY = 0;
let glu_direction_fixedX = 0;
let glu_direction_fixedY = 0;
let glu_mouselocationX = canvas.width * 0.5;
let glu_mouselocationY = canvas.height * 0.5;
let mouseLocationXLocalAlways = 0;
let mouseLocationYLocalAlways = 0;

function getImageLabelL() 
{
    return $("#Label_L_override")[0].value || L_filename;
}
function getImageLabelR() 
{
    return $("#Label_R_override")[0].value || R_filename;
}

glsl.on("render", function(e) {
    const glcontainer = $('#glcontainer');
    var offset = glcontainer.offset();

    $('#uicontainer')
        .css('left', offset.left)
        .css('top', offset.top)
        .width (glcontainer.width())
        .height(glcontainer.height());

    uicanvas.width  = canvas.width;
    uicanvas.height = canvas.height;
    
    const fontsize = $("#fontsize")[0].value;
    const font_color = $(".font_color")[0].value;
    const TEXT_MARGIN = 15;

    const Location = {
        LT : 1,
        RT : 2,
        LB : 3,
        RB : 4
    };
    function drawText(text, location) {
        if(fontsize == "0") {
            return;
        }
        uictx.save();
        uictx.font = fontsize + "px Arial";
        uictx.fillStyle = font_color;
        uictx.strokeStyle = "white";

        uictx.lineWidth = parseFloat(fontsize) / 6.0;
        uictx.lineJoin = "round";
        
        let x, y;
        if(location == Location.LT || location == Location.RT){
            uictx.textBaseline = "top";
            y = TEXT_MARGIN;
        } else {
            uictx.textBaseline = "bottom";
            y = uicanvas.height - TEXT_MARGIN;
        }
        if(location == Location.LT || location == Location.LB){
            uictx.textAlign = "left";
            x = TEXT_MARGIN;
        } else {
            uictx.textAlign = "right";
            x = uicanvas.width - TEXT_MARGIN;
        }
        
        uictx.strokeText(text, x, y);
        uictx.fillText(text, x, y);
        uictx.restore();
    }

    let label_L = getImageLabelL();
    let label_R = getImageLabelR();

    const fixed_direction = $('[name="fixed_direction"] option:selected').val();
    if(fixed_direction) {
        // fixed label
        if(fixed_direction === "↘") {
            drawText(label_L, Location.LT);
            drawText(label_R, Location.RB);
        }
        if(fixed_direction === "↗") {
            drawText(label_L, Location.LB);
            drawText(label_R, Location.RT);
        }
        if(fixed_direction === "↖") {
            drawText(label_L, Location.RB);
            drawText(label_R, Location.LT);
        }
        if(fixed_direction === "↙") {
            drawText(label_L, Location.RT);
            drawText(label_R, Location.LB);
        }
    } else {
        // automatic
        if(angle < -135.0) {
            drawText(label_L, Location.RT);
            drawText(label_R, Location.LT);
        }
        else if(-135.0 <= angle && angle < -95.0) {
            drawText(label_L, Location.RT);
            drawText(label_R, Location.LB);
        }
        else if(-95.0 <= angle && angle < -85.0) {
            drawText(label_L, Location.LT);
            drawText(label_R, Location.LB);
        }
        else if(-85.0 <= angle && angle < -45.0) {
            drawText(label_L, Location.LT);
            drawText(label_R, Location.RB);
        }
        else if(-45.0 <= angle && angle < 45.0) {
            drawText(label_L, Location.LT);
            drawText(label_R, Location.RT);
        } else if(45.0 <= angle && angle < 85.0) {
            drawText(label_L, Location.LB);
            drawText(label_R, Location.RT);
        } else if(85.0 <= angle && angle < 95.0) {
            drawText(label_L, Location.LB);
            drawText(label_R, Location.LT);
        } else if(95.0 <= angle && angle < 135.0) {
            drawText(label_L, Location.RB);
            drawText(label_R, Location.LT);
        }
        else if(135.0 <= angle && angle <= 180.0) {
            drawText(label_L, Location.RT);
            drawText(label_R, Location.LT);
        }
    }

    if( isSliceGraphShowing )
    {
        let isInteractable = sliceMode !== SLICE_MODE_NONE || distanceLinePoint(
                sliceVertices[0].x * uicanvas.width, sliceVertices[0].y * uicanvas.height, 
                sliceVertices[1].x * uicanvas.width, sliceVertices[1].y * uicanvas.height,
                mouseLocationXLocalAlways,
                mouseLocationYLocalAlways
        ) < SLICE_VERTEX_RADIUS;

        // flip y and relative to absolute
        let p0x = sliceVertices[0].x * uicanvas.width;
        let p0y = uicanvas.height - 1 - sliceVertices[0].y * uicanvas.height;
        let p1x = sliceVertices[1].x * uicanvas.width;
        let p1y = uicanvas.height - 1 - sliceVertices[1].y * uicanvas.height;

        // arrow
        let dx = p1x - p0x;
        let dy = p1y - p0y;
        let dLength = Math.sqrt(dx * dx + dy * dy);
        dx /= dLength;
        dy /= dLength;
        let theta = 30.0 * Math.PI / 180.0;
        let arrowTheta0 = Math.PI - theta;
        let arrowTheta1 = Math.PI + theta;
        let dxArrow0 = Math.cos(arrowTheta0) * dx - Math.sin(arrowTheta0) * dy;
        let dyArrow0 = Math.sin(arrowTheta0) * dx + Math.cos(arrowTheta0) * dy;
        let dxArrow1 = Math.cos(arrowTheta1) * dx - Math.sin(arrowTheta1) * dy;
        let dyArrow1 = Math.sin(arrowTheta1) * dx + Math.cos(arrowTheta1) * dy;
    
        uictx.lineCap = "round";
        uictx.beginPath();
        uictx.arc(p0x, p0y, SLICE_VERTEX_RADIUS * 0.5 /* R */, 0, 2 * Math.PI, false);
        uictx.lineWidth = isInteractable ? 8 : 6;
        uictx.strokeStyle = isInteractable ? 'rgba(255, 255, 255, 1)' : 'rgba(255, 255, 255, 0.8)';
        uictx.stroke();

        function arrowPath(ctx)
        {
            ctx.moveTo(p0x, p0y);
            ctx.lineTo(p1x, p1y);
            ctx.moveTo(p1x, p1y);
            ctx.lineTo(p1x + dxArrow0 * SLICE_VERTEX_RADIUS * 0.8, p1y + dyArrow0 * SLICE_VERTEX_RADIUS * 0.8);
            ctx.moveTo(p1x, p1y);
            ctx.lineTo(p1x + dxArrow1 * SLICE_VERTEX_RADIUS * 0.8, p1y + dyArrow1 * SLICE_VERTEX_RADIUS * 0.8);
        };
    
        uictx.beginPath();
        arrowPath(uictx);
        uictx.lineWidth = isInteractable ? 6 : 4;
        uictx.strokeStyle = isInteractable ? 'rgba(255, 255, 255, 1)' : 'rgba(255, 255, 255, 0.8)';
        uictx.stroke();

        uictx.beginPath();
        uictx.arc(p0x, p0y, SLICE_VERTEX_RADIUS * 0.5 /* R */, 0, 2 * Math.PI, false);
        uictx.lineWidth = 1.5;
        uictx.strokeStyle = isInteractable ? 'rgba(255, 0, 0, 1)' : 'rgba(230, 0, 0, 0.8)';
        uictx.stroke();

        uictx.beginPath();
        arrowPath(uictx);
        uictx.lineWidth = 1.5;
        uictx.strokeStyle = isInteractable ? 'rgba(255, 0, 0, 1)' : 'rgba(230, 0, 0, 0.8)';
        uictx.setLineDash([16, 8]);
        uictx.stroke();

        if(focusSliceAMT !== null)
        {
            let fx = lerp(p0x, p1x, focusSliceAMT);
            let fy = lerp(p0y, p1y, focusSliceAMT);

            uictx.beginPath();
            uictx.moveTo(fx - SLICE_VERTEX_RADIUS * 0.6, fy - SLICE_VERTEX_RADIUS * 0.6);
            uictx.lineTo(fx + SLICE_VERTEX_RADIUS * 0.6, fy + SLICE_VERTEX_RADIUS * 0.6);
            uictx.moveTo(fx - SLICE_VERTEX_RADIUS * 0.6, fy + SLICE_VERTEX_RADIUS * 0.6);
            uictx.lineTo(fx + SLICE_VERTEX_RADIUS * 0.6, fy - SLICE_VERTEX_RADIUS * 0.6);
            uictx.lineWidth = 5;
            uictx.strokeStyle = 'rgba(255, 255, 255, 1)';
            uictx.setLineDash([]);
            uictx.stroke();

            uictx.beginPath();
            uictx.moveTo(fx - SLICE_VERTEX_RADIUS * 0.6, fy - SLICE_VERTEX_RADIUS * 0.6);
            uictx.lineTo(fx + SLICE_VERTEX_RADIUS * 0.6, fy + SLICE_VERTEX_RADIUS * 0.6);
            uictx.moveTo(fx - SLICE_VERTEX_RADIUS * 0.6, fy + SLICE_VERTEX_RADIUS * 0.6);
            uictx.lineTo(fx + SLICE_VERTEX_RADIUS * 0.6, fy - SLICE_VERTEX_RADIUS * 0.6);
            uictx.lineWidth = 2;
            uictx.strokeStyle = 'rgba(255, 0, 255, 1)';
            uictx.setLineDash([]);
            uictx.stroke();
        }
    }
});

// UI Drawing
// setInterval(function () {
// }, 
// 100);

$(window).resize(invokeRender);

// we don't need auto rendering loop
glsl.pause();

// Load only the Fragment Shader
var fs = `
#extension GL_OES_standard_derivatives : enable
#ifdef GL_ES
precision mediump float;
#endif
    uniform vec2  u_resolution;
    uniform vec2  u_mouselocation;
    uniform vec2  u_direction;
    uniform vec2  u_direction_fixed;
    uniform float u_border;
    uniform vec3  u_border_color;
    uniform float u_diffmode;
    uniform float u_diffscale;

    uniform float u_loupemode;
    uniform float u_loupeSize;
    uniform float u_loupeScale;

    uniform float u_postProcess;
    uniform float u_postScale;
    uniform float u_postGamma;

    uniform float u_welchOverlay;

    uniform float u_hilightL;
    uniform float u_hilightR;

    uniform sampler2D u_image_L;
    uniform sampler2D u_image_R;
    uniform sampler2D u_image_welch;

    uniform vec3 u_Nan_Color;
    uniform vec3 u_Inf_Color;
    
    float border(vec2 fragcood, vec2 n, vec2 p) {
        float base = dot(p,        n);
        float x    = dot(fragcood, n);
        return x - base;
    }

    vec4 applyPost(vec4 c)
    {
        if( u_postProcess != 0.0 )
        {
            c.x = pow(u_postScale * c.x, 1.0 / u_postGamma);
            c.y = pow(u_postScale * c.y, 1.0 / u_postGamma);
            c.z = pow(u_postScale * c.z, 1.0 / u_postGamma);
        }
        return c;
    }

    // https://stackoverflow.com/questions/11810158/how-to-deal-with-nan-or-inf-in-opengl-es-2-0-shaders
    bool isnan( float val )
    {
        return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true;
    }
    #define FLT_MAX 3.402823466e+38
    bool isinf(float n) 
    {
        return FLT_MAX < abs(n);
    }
    vec4 GetImageL(vec2 st)
    {
        vec4 c = texture2D(u_image_L, st);

        if(isnan(c.x) || isnan(c.y) || isnan(c.z) || isnan(c.w)) {
            c = vec4(u_Nan_Color, 1.0);
        } else if( isinf(c.x) || isinf(c.y) || isinf(c.z) || isinf(c.w) ) {
            c = vec4(u_Inf_Color, 1.0);
        }
        return c;
    }
    vec4 GetImageR(vec2 st)
    {
        vec4 c = texture2D(u_image_R, st);
        if(isnan(c.x) || isnan(c.y) || isnan(c.z) || isnan(c.w)) {
            c = vec4(u_Nan_Color, 1.0);
        } else if( isinf(c.x) || isinf(c.y) || isinf(c.z) || isinf(c.w) ) {
            c = vec4(u_Inf_Color, 1.0);
        }
        return c;
    }
    vec4 addHilightL(vec4 c)
    {
        return mix(c, vec4(1.0), u_hilightL);
    }
    vec4 addHilightR(vec4 c)
    {
        return mix(c, vec4(1.0), u_hilightR);
    }

    void main() {
        vec2 fragcoord = gl_FragCoord.xy;
        vec2 st = fragcoord / u_resolution.xy;

        vec4 L = GetImageL(st);
        vec4 R = GetImageR(st);

        if(0.0 < u_diffmode) {
            L = abs(L - R) * u_diffscale;
        }

        L = addHilightL(L);
        R = addHilightR(R);

        if(0.1 < mod(u_border, 2.0)) {
            fragcoord += vec2(0.5);
        }

        // 
        vec2 direction = 0.0 < length(u_direction_fixed) ? u_direction_fixed : u_direction;
        
        float b = border(fragcoord, direction, u_mouselocation);

        bool is_straight = abs(direction.x) < 1.0e-5 || abs(direction.y) < 1.0e-5;
        float delta = is_straight ? 0.0 : 0.9 /* feeling constant */;

        float s = smoothstep(-delta, delta, b);

        gl_FragColor = mix(L, R, s);
        
        // Loupe
        float loupedelta = 0.9; 
        if(0.0 < u_loupemode)
        {
            float size = u_loupeSize;
            float scale = u_loupeScale;
            
            // center of loupe
            vec2 lhs = u_mouselocation - direction * size * 0.6 /*bias*/;
            {
                float alpha = 1.0 - smoothstep( size * 0.5 - loupedelta, size * 0.5 + loupedelta, distance(fragcoord, lhs) );
                vec2 localcoord = fragcoord - lhs;
                vec2 sample = (localcoord / scale + u_mouselocation)  / u_resolution.xy;
                gl_FragColor.rgb = mix(gl_FragColor.rgb, GetImageL(sample).rgb, alpha);
            }

            // center of loupe
            vec2 rhs = u_mouselocation + direction * size * 0.6 /*bias*/;
            {
                float alpha = 1.0 - smoothstep( size * 0.5 - loupedelta, size * 0.5 + loupedelta, distance(fragcoord, rhs) );
                vec2 localcoord = fragcoord - rhs;
                vec2 sample = (localcoord / scale + u_mouselocation)  / u_resolution.xy;
                gl_FragColor.rgb = mix(gl_FragColor.rgb, GetImageR(sample).rgb, alpha);
            }

            gl_FragColor = applyPost(gl_FragColor);

            if( 0.0 < u_border ) {
                float a = smoothstep(u_border * 0.5 - loupedelta, u_border * 0.5 + loupedelta, abs(distance(fragcoord, lhs) - size * 0.5));
                float b = smoothstep(u_border * 0.5 - loupedelta, u_border * 0.5 + loupedelta, abs(distance(fragcoord, rhs) - size * 0.5));
                gl_FragColor.rgb = mix(u_border_color, gl_FragColor.rgb, a * b);
            }
        }
        else
        {
            gl_FragColor = applyPost(gl_FragColor);
        }

        if(0.0 < u_border) {
            float bar = u_border * 0.5;
            float bar_window = smoothstep(bar - delta, bar + delta, abs(b));
            gl_FragColor.rgb = mix(u_border_color, gl_FragColor.rgb, bar_window);
        }

        // welch
        if( 0.0 < u_welchOverlay )
        {
            vec3 welch = texture2D( u_image_welch, st ).rgb;
            gl_FragColor.rgb = mix( gl_FragColor.rgb, welch, u_welchOverlay );
        }
        
        gl_FragColor.a = 1.0;
    }
`;
glsl.load(fs);

L_filename = "dogs-before";
R_filename = "dogs-after";
$('#Label_L_override').attr("placeholder", L_filename);
$('#Label_R_override').attr("placeholder", R_filename);

// Default Values
glsl.setUniform("u_image_L", "dogs-before.jpg");
glsl.setUniform("u_image_R", "dogs-after.jpg");
glsl.setUniform("u_direction", 1.0, 0.0);
glsl.setUniform("u_mouselocation", canvas.width * 0.5, canvas.height * 0.5);
glsl.setUniform("u_border", 2);
glsl.setUniform("u_border_color", 0.0, 0.0, 0.0);
glsl.setUniform("u_diffmode", 0.0);
glsl.setUniform("u_diffscale", 1.0);
glsl.setUniform("u_direction_fixed", 0.0, 0.0);
glsl.setUniform("u_loupeMode", 0.0);
glsl.setUniform("u_loupeSize", 150.0);
glsl.setUniform("u_loupeScale", 2.0);
glsl.setUniform("u_postProcess", 0.0);
glsl.setUniform("u_postScale", 1.0);
glsl.setUniform("u_postGamma", 2.2);
glsl.setUniform("u_welchOverlay", 0.0);
glsl.setUniform("u_hilightL", 0.0);
glsl.setUniform("u_hilightR", 0.0);
glsl.setUniform("u_Nan_Color", 1.0, 0.0, 0.0);
glsl.setUniform("u_Inf_Color", 1.0, 0.0, 1.0);
{
    let nPixels = 2 * 2;
    let rgba = new Float32Array(nPixels * 4);
    for (let i = 0; i < nPixels; i++) {
        rgba[i * 4 + 0] = 1.0;
        rgba[i * 4 + 1] = 1.0;
        rgba[i * 4 + 2] = 1.0;
        rgba[i * 4 + 3] = 1.0;
    }
    glsl.setUniform("u_image_welch", { width:2, height:2, data:rgba });
}

// Mouse Move & Mouse Up is need global event  -> html
// Mouse Down shouldn't work outside of canvas -> EVENT_VIEW
const EVENT_VIEW = "#uicanvas";

var down = false;

// mouseLocationXLocalAlways, mouseLocationYLocalAlways are always updated.
// glu_mouselocationX, glu_mouselocationY and glsl.setUniform are updated just when down == true
function updateMouseLocation(e) {
    {
        // Coordinate transform
        // https://qiita.com/yukiB/items/cc533fbbf3bb8372a924#2-jquery%E3%81%AEoffset%E3%81%A8eventpagexy%E3%82%92%E4%BD%BF%E7%94%A8
        const offset = $('#glcanvas').offset();
        const x = e.pageX - offset.left;
        const y = e.pageY - offset.top;
        e.offsetX = x;
        e.offsetY = y;
    }
    const scale = canvas.width / canvas.clientWidth;
    const x = e.offsetX * scale;
    const y = canvas.height - e.offsetY * scale;
    if(down) {
        glu_mouselocationX = x;
        glu_mouselocationY = y;
        glsl.setUniform("u_mouselocation", Math.round(x), Math.round(y));
    }
    mouseLocationXLocalAlways = x;
    mouseLocationYLocalAlways = y;
}

function Clamp(x, lower, upper) {
  return Math.min(Math.max(x, lower), upper);
}

$("html").mousemove(function(e) {
    updateMouseLocation(e);

    if(sliceMode !== SLICE_MODE_NONE)
    {
        let newX = Clamp(mouseLocationXLocalAlways / uicanvas.width, 0, 1);
        let newY = Clamp(mouseLocationYLocalAlways / uicanvas.height, 0, 1);
        if(sliceMode == SLICE_MODE_DRAG)
        {
            sliceVertices[sliceVertexGrab].x = newX;
            sliceVertices[sliceVertexGrab].y = newY;
        }
        else if (sliceMode == SLICE_MODE_NEW)
        {
            sliceVertices[1].x = newX;
            sliceVertices[1].y = newY;
        }
        else if( sliceMode == SLICE_MODE_DRAG_LINE )
        {
            let dx = (mouseLocationXLocalAlways - grabbaseX) / uicanvas.width;
            let dy = (mouseLocationYLocalAlways - grabbaseY) / uicanvas.height;
            for(let i = 0 ; i < 2 ; ++i)
            {
                sliceVertices[i].x = Clamp((grabbaseVertices[i].x + dx), 0, 1);
                sliceVertices[i].y = Clamp((grabbaseVertices[i].y + dy), 0, 1);
            }
        }

        onSliceGraphUpdate();
    }
    if( isSliceGraphShowing )
    {
        invokeRender();
    }
    
    // disable drag selection effects.
    const uidialog = $('.ui-dialog');
    if (0 < uidialog.length && uidialog.is(':hover')) {
        e.preventDefault();
    }
});
$("html").mouseup(function() {
    down = false;
    sliceVertexGrab = -1;
    sliceMode = SLICE_MODE_NONE;
});
$(EVENT_VIEW).mouseup(function(e) {
    down = false;
    sliceVertexGrab = -1;
    sliceMode = SLICE_MODE_NONE;
});
$(EVENT_VIEW).mouseleave(function(e){
    updateMouseLocation(e);
});

function distanceLinePoint(p0x, p0y, p1x, p1y, ox, oy)
{
    let p0 = {x:p0x, y:p0y};
    let p1 = {x:p1x, y:p1y};
    let o = {x:ox, y:oy};
    let a = sub(o, p0);
    let b = sub(p1, p0);
    let c = Clamp(dot(a, b) / dot(b, b), 0, 1);
    let onLine = add(p0, mulScalar(b, c));
    let between = sub(onLine, o);
    return Math.sqrt(dot(between, between));
}

$(EVENT_VIEW).mousedown(function(e){
    updateMouseLocation(e);

    if( isSliceGraphShowing )
    {
        sliceVertexGrab = -1;
        for(let i = 0 ; i < sliceVertices.length ; ++i)
        {
            let sliceX = sliceVertices[i].x * uicanvas.width;
            let sliceY = sliceVertices[i].y * uicanvas.height;
            let d = Math.sqrt(Math.pow(sliceX - mouseLocationXLocalAlways, 2) + Math.pow(sliceY - mouseLocationYLocalAlways, 2));
            if(d < SLICE_VERTEX_RADIUS)
            {
                sliceVertexGrab = i;
                break;
            }
        }
        if(0 <= sliceVertexGrab)
        {
            sliceMode = SLICE_MODE_DRAG;
        }
        else
        {
            let d = distanceLinePoint(
                sliceVertices[0].x * uicanvas.width, sliceVertices[0].y * uicanvas.height, 
                sliceVertices[1].x * uicanvas.width, sliceVertices[1].y * uicanvas.height,
                mouseLocationXLocalAlways,
                mouseLocationYLocalAlways
            );
            if(d < SLICE_VERTEX_RADIUS)
            {
                sliceMode = SLICE_MODE_DRAG_LINE;

                for(let i = 0 ; i < 2 ; ++i)
                {
                    grabbaseVertices[i].x = sliceVertices[i].x;
                    grabbaseVertices[i].y = sliceVertices[i].y;
                }
                grabbaseX = mouseLocationXLocalAlways;
                grabbaseY = mouseLocationYLocalAlways;
            }
            else
            {
                sliceMode = SLICE_MODE_NEW;
    
                sliceVertices[0].x = sliceVertices[1].x = Clamp(mouseLocationXLocalAlways / uicanvas.width, 0, 1);
                sliceVertices[0].y = sliceVertices[1].y = Clamp(mouseLocationYLocalAlways / uicanvas.height, 0, 1);
                invokeRender();
            }
        }

        onSliceGraphUpdate();
    }
    else
    {
        sliceMode = SLICE_MODE_NONE;
    }
    if(sliceMode !== SLICE_MODE_NONE)
    {
        return;
    }

    down = true;
    updateMouseLocation(e);
});

// Direction
const DIAL_STEPS = 100.0;
$(".direction_dial").attr("value", DIAL_STEPS / 4).knob({
    'max' : DIAL_STEPS,
    'height' : 110,
    'fgColor' : "#2A2A2A",
    'change' : function (v) { 
        const clock = this.cv;
        const tick = (clock - DIAL_STEPS / 4.0);
        const radian = -tick / DIAL_STEPS * Math.PI * 2;
        angle = radian / (2.0 * Math.PI) * 360.0;
        if(angle <= -180.0) {
            angle += 360.0;
        }
        glu_directionX = Math.cos(radian);
        glu_directionY = Math.sin(radian);
        glsl.setUniform("u_direction", glu_directionX, glu_directionY);
        
        // move to free mode
        $('#fixed_direction').val("");
        $("#dial_container").css("opacity", 1.0);

        glu_direction_fixedX = 0;
        glu_direction_fixedY = 0;
        glsl.setUniform("u_direction_fixed", glu_direction_fixedX, glu_direction_fixedY);
    }
});

$("#fixed_direction").on("change", function(e){
    const value = this.value;
    if(value) {
        $("#dial_container").css("opacity", 0.3);
        glu_mouselocationX = canvas.width * 0.5;
        glu_mouselocationY = canvas.height * 0.5;
        glsl.setUniform("u_mouselocation", glu_mouselocationX , glu_mouselocationY);

        const L = Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height);
        if(value === "↘") {
            glu_direction_fixedX = canvas.height / L;
            glu_direction_fixedY = -canvas.width / L;
        }
        if(value === "↗") {
            glu_direction_fixedX = canvas.height / L;
            glu_direction_fixedY = canvas.width / L;
        }
        if(value === "↖") {
            glu_direction_fixedX = -canvas.height / L;
            glu_direction_fixedY = canvas.width / L;
        }
        if(value === "↙") {
            glu_direction_fixedX = -canvas.height / L;
            glu_direction_fixedY = -canvas.width / L;
        }
    } else {
        glu_direction_fixedX = 0;
        glu_direction_fixedY = 0;
        $("#dial_container").css("opacity", 1.0);
    }
    glsl.setUniform("u_direction_fixed", glu_direction_fixedX, glu_direction_fixedY);
    invokeRender();
});

// Border
$("#border").on("input", function(e){
    const value = this.value;
    glsl.setUniform("u_border", parseFloat(value));
    $("#borderlabel").text(value + "px");
});

// Border color
var hueb_border = new Huebee( '.border_color', {
  notation: 'hex',
  saturations: 2,
});
hueb_border.on( 'change', function( color, hue, sat, lum ) {
    const R = color.slice(1, 3);
    const G = color.slice(3, 5);
    const B = color.slice(5, 7);
    const r = parseInt(R, 16) / 255.0;
    const g = parseInt(G, 16) / 255.0;
    const b = parseInt(B, 16) / 255.0;
    glsl.setUniform("u_border_color", r, g, b);
});

$('#Label_L_override').on('input', function () {
    invokeRender();
});
$('#Label_R_override').on('input', function () {
    invokeRender();
});

$("#fontsize").on("input", function(e){
    const value = this.value;
    invokeRender();
    $("#fontsizelabel").text(value + "px");
});
// from URL Params
const url = new URL(location);
const fontsize = url.searchParams.get('fontsize');
if(fontsize) {
    $("#fontsize").val(fontsize);
    $("#fontsizelabel").text(fontsize + "px");
}

var hueb_font = new Huebee( '.font_color', {
  notation: 'hex',
  saturations: 2,
});
hueb_font.on( 'change', function( color, hue, sat, lum ) {
    const R = color.slice(1, 3);
    const G = color.slice(3, 5);
    const B = color.slice(5, 7);
    const r = parseInt(R, 16) / 255.0;
    const g = parseInt(G, 16) / 255.0;
    const b = parseInt(B, 16) / 255.0;
    invokeRender();
});

var hueb_Nan_Color = new Huebee( '.Nan_Color', {
  notation: 'hex',
  saturations: 2,
});
hueb_Nan_Color.on( 'change', function( color, hue, sat, lum ) {
    const R = color.slice(1, 3);
    const G = color.slice(3, 5);
    const B = color.slice(5, 7);
    const r = parseInt(R, 16) / 255.0;
    const g = parseInt(G, 16) / 255.0;
    const b = parseInt(B, 16) / 255.0;
    glsl.setUniform("u_Nan_Color", r, g, b);
});

var hueb_Inf_Color = new Huebee( '.Inf_Color', {
  notation: 'hex',
  saturations: 2,
});
hueb_Inf_Color.on( 'change', function( color, hue, sat, lum ) {
    const R = color.slice(1, 3);
    const G = color.slice(3, 5);
    const B = color.slice(5, 7);
    const r = parseInt(R, 16) / 255.0;
    const g = parseInt(G, 16) / 255.0;
    const b = parseInt(B, 16) / 255.0;
    glsl.setUniform("u_Inf_Color", r, g, b);
});

function didChangeDiffMode(value) {
    glsl.setUniform("u_diffmode", value ? 1.0 : 0.0);
    const op = value ? 1.0 : 0.3;
    $("#diffscalelabel").css("opacity", op);
    $("#diffscale").css("opacity", op);
}
// Border
$("#diffscale").on("input", function(e) {
    const value = this.value;
    const scale = parseFloat(value) / 100.0;
    glsl.setUniform("u_diffscale", scale);
    $("#diffscalelabel").text(value + " %");
});

// paste
function imagePaste(sampler, dataURL) {
    glsl.setUniform(sampler, null);
    glsl.setUniform(sampler, dataURL);

    const image = new Image();
    image.onload = function() {
        canvas.width = image.width;
        canvas.height = image.height;
    };
    image.src = dataURL;
}

$('.PasteAreaL').pastableNonInputable();
$('.PasteAreaL').on('pasteImage', function(ev, data) {
    L_filename = "clipboard L";
    updatePlaceHolder();
    imagePaste("u_image_L", data.dataURL);
});
$('.PasteAreaR').pastableNonInputable();
$('.PasteAreaR').on('pasteImage', function(ev, data) {
    R_filename = "clipboard R";
    updatePlaceHolder();
    imagePaste("u_image_R", data.dataURL);
});

function didChangeLoupeMode(value) {
    glsl.setUniform("u_loupemode", value ? 1.0 : 0.0);
    const op = value ? 1.0 : 0.3;
    $("#loupeSizeLabel").css("opacity", op);
    $("#loupeSize").css("opacity", op);

    $("#loupeScaleLabel").css("opacity", op);
    $("#loupeScale").css("opacity", op);
}
function didChangePostProcess(value) {
    glsl.setUniform("u_postProcess", value ? 1.0 : 0.0);
    const op = value ? 1.0 : 0.3;
    $("#postScaleLabel").css("opacity", op);
    $("#postScale").css("opacity", op);
    $("#GammaSelect").css("opacity", op);
}

$("#loupeSize").on("input", function(e) {
    const value = this.value;
    const size = parseFloat(value);
    glsl.setUniform("u_loupeSize", size);
    $("#loupeSizeLabel").text(size + " px");
});
$("#loupeScale").on("input", function(e) {
    const value = this.value;
    const scale = parseFloat(value) / 100.0;
    glsl.setUniform("u_loupeScale", scale);
    $("#loupeScaleLabel").text(value + " %");
});

$("#postScale").on("input", function(e) {
    const value = this.value;
    const scale = parseFloat(value) / 100.0;
    glsl.setUniform("u_postScale", scale);
    $("#postScaleLabel").text(value + " %");
});
$("#GammaSelect").change(function() {
    let value = $(this).val();
    glsl.setUniform("u_postGamma", parseFloat(value));
});

$("#WelchSlider").on("input", function(e) {
    const value = this.value;
    const scale = parseFloat(value) / 100.0;
    glsl.setUniform("u_welchOverlay", scale);
});


// on save
function onSave() {
    compositecanvas.width = canvas.width;
    compositecanvas.height = canvas.height;
    const compositecanvasCtx = compositecanvas.getContext('2d');
    compositecanvasCtx.drawImage(canvas, 0, 0);
    compositecanvasCtx.drawImage(uicanvas, 0, 0);

    var imgdata = compositecanvas.toDataURL('image/png');
    saveAs(imgdata, "compare.png");
}

// function onDebug() {
//     glsl.setUniform("u_image_L", null);

//     let raw = new Uint8Array([
//         0, 0, 0, 255, 
//         255, 0, 0, 255,
//         0, 255, 0, 255,
//         0, 0, 255, 255]);
//     let rawf = new Float32Array([
//         0, 0, 0, 1.0, 
//         Math.random(), 0.5, 0, 1.0,
//         0, 1.0, 0.5, 1.0,
//         0.5, 0, 1.0, 1.0,
    
//         Math.random(), Math.random(), Math.random(), 1.0,
//         Math.random(), Math.random(), Math.random(), 1.0]
//     );
//     glsl.setUniform("u_image_L", { width:2, height:3, data:rawf });
// }

var dragoverHandler = function(e){
    e.preventDefault();
    $(this).addClass("dragover");

    let objectID = $(this).attr("id");
    if(objectID === "drop-zoneL")
    {
        glsl.setUniform("u_hilightL", HILIGHT_VALUE);
    }
    else if(objectID == "drop-zoneR")
    {
        glsl.setUniform("u_hilightR", HILIGHT_VALUE);
    }
};
$("#drop-zoneL").on("dragover", dragoverHandler);
$("#drop-zoneR").on("dragover", dragoverHandler);

var dragleaveHandler = function(e){
    e.preventDefault();
    $(this).removeClass("dragover");

    let objectID = $(this).attr("id");
    if(objectID === "drop-zoneL")
    {
        glsl.setUniform("u_hilightL", 0);
    }
    else if(objectID == "drop-zoneR")
    {
        glsl.setUniform("u_hilightR", 0);
    }
};
$("#drop-zoneL").on("dragleave", dragleaveHandler);
$("#drop-zoneR").on("dragleave", dragleaveHandler);

function rmExt(s) {
    return s.replace(/\.[^/.]+$/, "");
}
function updatePlaceHolder() {
    $('#Label_L_override').attr("placeholder", L_filename);
    $('#Label_R_override').attr("placeholder", R_filename);
}
var handleDrop = function(file, sampler, isLeft) {
    if(isLeft) {
        L_filename = rmExt(file.name);
    } else {
        R_filename = rmExt(file.name);
    }
    updatePlaceHolder();

    let isExr = file.name.endsWith('.exr');

    let reader = new FileReader();
    reader.onload = function(event) {
        glsl.setUniform(sampler, null);

        if(isExr)
        {
            window.loadExr( event.target.result, function(exrImage) {
                console.log(exrImage.width, exrImage.height);

                let channels = exrImage.channels();
                console.log(channels);
                
                let r = null;
                let g = null;
                let b = null;
                for(let i = 0 ; i < channels.length ; i++)
                {
                    let ch = channels[i];
                    let chlower = ch.toLowerCase();
                    if(chlower.endsWith('r'))
                    {
                        r = exrImage.plane(ch);
                    }
                    else if(chlower.endsWith('g'))
                    {
                        g = exrImage.plane(ch);
                    }
                    else if(chlower.endsWith('b'))
                    {
                        b = exrImage.plane(ch);
                    }
                }

                let nPixels = exrImage.width * exrImage.height;
                let rgba = new Float32Array(nPixels * 4);
                for (let i = 0; i < nPixels; i++) {
                    let rval = r != null ? r[i] : 0.0;
                    let gval = g != null ? g[i] : 0.0;
                    let bval = b != null ? b[i] : 0.0;
                    rgba[i * 4 + 0] = rval;
                    rgba[i * 4 + 1] = gval;
                    rgba[i * 4 + 2] = bval;
                    rgba[i * 4 + 3] = 1.0;
                }

                glsl.setUniform(sampler, { width:exrImage.width, height:exrImage.height, data:rgba });

                canvas.width = exrImage.width;
                canvas.height = exrImage.height;

                if(isLeft)
                {
                    floatImageL = rgba;
                }
                else
                {
                    floatImageR = rgba;
                }
                floatImageWidth = exrImage.width;
                floatImageHeight = exrImage.height;

                onTriggeredUpdateImage();
            } );
        }
        else
        {
            glsl.setUniform(sampler, event.target.result);
            const image = new Image();
            image.onload = function() {
                canvas.width = image.width;
                canvas.height = image.height;
            };
            image.src = event.target.result;

            if(isLeft)
            {
                floatImageL = null;
            }
            else
            {
                floatImageR = null;
            }
            floatImageWidth = 0;
            floatImageHeight = 0;

            onTriggeredUpdateImage();
        }
    }
    
    if(isExr)
    {
        reader.readAsArrayBuffer(file);
    }
    else
    {
        reader.readAsDataURL(file);
    }
};
$("#drop-zoneL").on("drop", function(e) {
    e.preventDefault();
    $(this).removeClass("dragover");
    if(0 < e.originalEvent.dataTransfer.files.length)
    {
        handleDrop(e.originalEvent.dataTransfer.files[0], "u_image_L", true);
    }

    glsl.setUniform("u_hilightL", 0);
    glsl.setUniform("u_hilightR", 0);
});
$("#drop-zoneR").on("drop", function(e) {
    e.preventDefault();
    $(this).removeClass("dragover");
    if(0 < e.originalEvent.dataTransfer.files.length)
    {
        handleDrop(e.originalEvent.dataTransfer.files[0], "u_image_R", false);
    }

    glsl.setUniform("u_hilightL", 0);
    glsl.setUniform("u_hilightR", 0);
});

function sqr(x) { return x * x; }
function mouseBorder()
{
    const useFixed = 0.0 < (sqr(glu_direction_fixedX) + sqr(glu_direction_fixedY));
    let dirX = useFixed ? glu_direction_fixedX : glu_directionX;
    let dirY = useFixed ? glu_direction_fixedY : glu_directionY;
    let base = glu_mouselocationX * dirX + glu_mouselocationY * dirY;
    let x    = mouseLocationXLocalAlways * dirX + mouseLocationYLocalAlways * dirY;
    let border = x - base;
    return border; 
}


$(document).on('dragover drop', function (e) {
    // update location for drag and drop
    updateMouseLocation(e);

    // ignore drop outside of the drop area.
    e.stopPropagation();
    e.preventDefault();
    
    return false;
});

// Control hilight
$("#uicanvas").on('dragover', function (e) {
    let border = mouseBorder();
    // console.log(border);
    if(border < 0.0)
    {
        glsl.setUniform("u_hilightL", HILIGHT_VALUE);
        glsl.setUniform("u_hilightR", 0.0);
    }
    else
    {
        glsl.setUniform("u_hilightL", 0);
        glsl.setUniform("u_hilightR", HILIGHT_VALUE);
    }
    
    e.preventDefault();
});

$("#uicanvas").on('drop', function (e) {
    if(0 < e.originalEvent.dataTransfer.files.length)
    {
        let border = mouseBorder();
        if(border < 0.0)
        {
            handleDrop(e.originalEvent.dataTransfer.files[0], "u_image_L", true);
        }
        else
        {
            handleDrop(e.originalEvent.dataTransfer.files[0], "u_image_R", false);
        }
    }

    glsl.setUniform("u_hilightL", 0);
    glsl.setUniform("u_hilightR", 0);
    
    e.stopPropagation();
    e.preventDefault();
});
$("#uicanvas").on("dragleave", function (e) {
    glsl.setUniform("u_hilightL", 0);
    glsl.setUniform("u_hilightR", 0);
    updateMouseLocation(e);
});

$("#drop-zoneL").on("click", function(e) {
    const input = document.createElement('input');
    input.type = 'file';
    input.onchange = event => { 
        handleDrop(event.target.files[0], "u_image_L", true);
    };
    input.click();
});
$("#drop-zoneR").on("click", function(e) {
    const input = document.createElement('input');
    input.type = 'file';
    input.onchange = event => { 
        handleDrop(event.target.files[0], "u_image_R", false);
    };
    input.click();
});

function avariableWelch()
{
    if( floatImageWidth !== 0 && floatImageHeight !== 0 && floatImageL !== null && floatImageR !== null && floatImageL.length === floatImageR.length )
    {
        return true;
    }
    return false;
}

function updateWelchUI()
{
    var enable = avariableWelch();
    const op = enable ? 1.0 : 0.3;
    $("#WelchLabel").css("opacity", op);
    $("#WelchButton").css("opacity", op);
    $("#WelchSlider").css("opacity", op);
}
setInterval("updateWelchUI()", 500); 

class OnlineVariance {
    constructor() {
        this._count = 0;
        this._mean = 0;
        this._M2 = 0;
    }
    addSample( newValue ) {
        this._count++;
        let delta = newValue - this._mean;
        this._mean += delta / this._count;
        let delta2 = newValue - this._mean;
        this._M2 += delta * delta2;
    }
    mean() {
        return this._mean;
    }
    sampleVariance() {
        if (this._count == 0)
        {
            return 0.0;
        }
        return this._M2 / this._count;
    }
    unbiasedVariance()  {
        if (this._count === 0)
        {
            return 0.0;
        }
        return this._M2 / (this._count - 1);
    }
    sampleCount() {
        return this._count;
    }
}
function sqr(x) {
    return x * x;
}
function gauss_Pnu(t)
{
    let tt = t > 0 ? t : -t;
    tt = tt / Math.sqrt(2.0);

    const x = 1.0 / (1.0 + 0.47047 * tt);
    const erf = 1.0 - x * (0.3480242
        + x * (-0.0958798
            + 0.7478556 * x))
        * Math.exp(-tt * tt);
    return 1.0 - erf;
}
// color coding
// input float between 0 and 1
// output colour ramp
function viridis_quintic( x )     
{
    x = Math.min(1.0, x);
    const x2 = x * x;
    const x3 = x2 * x;
    const x4 = x2 * x2;
    const x5 = x3 * x2;
    let col = [0.0, 0.0, 0.0];
    col[0] = +0.280268003 - 0.143510503 * x + 2.225793877 * x2 - 14.815088879 * x3 + 25.212752309 * x4 - 11.772589584 * x5;
    col[1] = -0.002117546 + 1.617109353 * x - 1.909305070 * x2 + 2.701152864 * x3 - 1.685288385 * x4 + 0.178738871 * x5;
    col[2] = +0.300805501 + 2.614650302 * x - 12.019139090 * x2 + 28.933559110 * x3 - 33.491294770 * x4 + 13.762053843 * x5;
    return col;
}

let pHistgram = [];

const wcanvas = document.getElementById('wcanvas');
wcanvas.width = 300;
wcanvas.height = 215;
const wctx = wcanvas.getContext('2d');

function toFixed(value, precision) {
    var power = Math.pow(10, precision || 0);
    return String(Math.round(value * power) / power);
}
let labels = []
for(let i = 0 ; i < 10 ; i++)
{
    labels.push(toFixed(i / 10.0, 2) + "-" + toFixed((i + 1) / 10.0, 2) );
    // pHistgram.push(Math.random() * 100.0);
    pHistgram.push(0);
}
Chart.defaults.global.animation.duration = 300;
let chart = new Chart(wctx, {
    type: 'horizontalBar',
    data: {
        labels: labels,
        datasets: [{
            label: 'p Value Histgram',
            backgroundColor: 'rgb(255, 99, 132)',
            borderColor: 'rgb(255, 99, 132)',
            data: pHistgram
        }]
    },

    // Configuration options go here
    options: {
        scales: {
            xAxes: [{
                ticks: {
                    beginAtZero: true
                }
            }]
        },
        responsive: true, 
        maintainAspectRatio: false
    }
});

function onWelch()
{
    if( avariableWelch() )
    {
        // ok
    }
    else
    {
        return;
    }

    let onlineVar = new OnlineVariance();
    onlineVar.addSample(1);
    onlineVar.addSample(3);
    onlineVar.addSample(4);

    let tileSize = 30;
    let tileCountX = Math.floor(floatImageWidth / tileSize);
    let tileCountY = Math.floor(floatImageHeight / tileSize);

    let nPixels = floatImageWidth * floatImageHeight;
    let rgba = new Float32Array(nPixels * 4);

    for(let i = 0 ; i < 10 ; ++i)
    {
        pHistgram[i] = 0;
    }

    for (let yi = 0; yi < tileCountY; ++yi)
    {
        for (let xi = 0; xi < tileCountX; ++xi)
        {
            let minP = 1.0;

            // per compornent
            for(let i = 0 ; i < 3 ; ++i)
            {
                let va1 = new OnlineVariance();
                let va2 = new OnlineVariance();
                for(let y = 0; y < tileSize; ++y)
                {
                    for (let x = 0; x < tileSize; ++x)
                    {
                        let sX = xi * tileSize + x;
                        let sY = yi * tileSize + y;
                        let sIndex = sY * floatImageWidth + sX;
                        va1.addSample( floatImageL[sIndex * 4 + i] );
                        va2.addSample( floatImageR[sIndex * 4 + i] );
                    }
                }

                let SEwSquared =
                    va1.unbiasedVariance() / va1.sampleCount()
                    +
                    va2.unbiasedVariance() / va2.sampleCount();
                let SEw = Math.sqrt( SEwSquared );

                // final p value
                let p;

                if ( SEw < Number.EPSILON )
                {
                    p = 1.0;
                }
                else
                {
                    // t value
                    let t = ( va1.mean() - va2.mean() ) / SEw;

                    // TODO 
                    // Degree of Freedom
                    // let nuf =
                    //     sqr(SEwSquared) /
                    //     (
                    //         sqr( va1.unbiasedVariance() ) / ( sqr( va1.sampleCount() ) * ( va1.sampleCount() - 1 ) )
                    //         +                                      
                    //         sqr( va2.unbiasedVariance() ) / ( sqr( va2.sampleCount() ) * ( va2.sampleCount() - 1 ) )
                    //     );
                    // let nu = Math.round( nuf );
                    // console.log(nu);

                    // if( nu < 20 )
                    // {
                    //     p = 2.f * t_Pnu_half(-std::fabs(t), nu );
                    // }
                    // else
                    // {
                    //     p = gauss_Pnu( t );
                    // }

                    p = gauss_Pnu( t );
                    
                    // calc histgram
                    const index = Math.min(Math.floor(p * 10.0), 9);
                    // console.log(p + "/" + index);
                    pHistgram[index]++;
                }

                minP = Math.min(minP, p);
            }

            // glm::vec3 color;
            // viridis_quintic(p, glm::value_ptr(color));
            // pImage(xi, yi) = glm::vec4(color, 1.0f);
            var color = viridis_quintic( minP );
            // let mean = va1.mean();
            for(let y = 0; y < tileSize; ++y)
            {
                for (let x = 0; x < tileSize; ++x)
                {
                    let sX = xi * tileSize + x;
                    let sY = yi * tileSize + y;
                    let dIndex = sY * floatImageWidth + sX;
                    rgba[dIndex * 4]   = color[0];
                    rgba[dIndex * 4+1] = color[1];
                    rgba[dIndex * 4+2] = color[2];
                    rgba[dIndex * 4+3] = 1.0;
                }
            }
        }
    }

    // console.log(pHistgram);
    chart.update();

    glsl.setUniform("u_image_welch", { width:floatImageWidth, height:floatImageHeight, data:rgba });

    $("#WelchSlider").val(100);
    glsl.setUniform("u_welchOverlay", 1.0);
    $("#pUI").show();
}
// left to right, top to bottom
// o.r, o.g, o.b, o.a, xi, yi will be filled.
function sampleNearestNeighbor(image, u, v, o)
{
    const xi = Clamp( Math.floor(image.width * u), 0, image.width - 1);
    const yi = Clamp( Math.floor(image.height * v), 0, image.height - 1);
    const index = (yi * image.width + xi) * 4;
    o.r = image.data[index];
    o.g = image.data[index+1];
    o.b = image.data[index+2];
    o.a = image.data[index+3];
    o.xi = xi;
    o.yi = yi;
}
function downloadTextureAsFloat(image)
{
    // the image might have float array already.
    if( image.source.constructor == Float32Array )
    {
        return {
            width: image.width,
            height: image.height,
            data: image.source
        };
    }

    glsl.gl.pixelStorei(glsl.gl.UNPACK_FLIP_Y_WEBGL, true);

    // https://stackoverflow.com/questions/4702032/accessing-image-texture-data-texels-on-webgl
    // Create a framebuffer backed by the texture
    let framebuffer = glsl.gl.createFramebuffer();
    glsl.gl.bindFramebuffer(glsl.gl.FRAMEBUFFER, framebuffer);
    glsl.gl.framebufferTexture2D(glsl.gl.FRAMEBUFFER, glsl.gl.COLOR_ATTACHMENT0, glsl.gl.TEXTURE_2D, image.texture, 0);

    // Read the contents of the framebuffer (data stores the pixel data)
    let dataU8 = new Uint8Array(image.width * image.height * 4);
    glsl.gl.readPixels(0, 0, image.width, image.height, glsl.gl.RGBA, glsl.gl.UNSIGNED_BYTE, dataU8);

    glsl.gl.deleteFramebuffer(framebuffer);

    let dataF32 = new Float32Array(image.width * image.height * 4);
    
    // flip vertially and u8 to f32
    for(let y = 0 ; y < image.height ; ++y)
    {
        let y_dst = y;
        let y_src = image.height - 1 - y;
        for(let x = 0 ; x < image.width ; ++x)
        {
            let src_index = (y_src * image.width + x) * 4;
            let dst_index = (y_dst * image.width + x) * 4;
            for(let i = 0 ; i < 4 ; ++i)
            {
                dataF32[src_index + i] = dataU8[dst_index + i] / 255.0;
            }
        }
    }
    return {
        width: image.width,
        height: image.height,
        data: dataF32
    };
}
function onTriggeredUpdateImage()
{
    // console.log("onTriggeredUpdateImage");
    glsl.textures["u_image_L"].loading.then( image => {
        imageLRaw = downloadTextureAsFloat(image);
    });
    glsl.textures["u_image_R"].loading.then( image => {
        imageRRaw = downloadTextureAsFloat(image);
    });
}

// Run once for initialize
onTriggeredUpdateImage();

let plot = null;
let sliceGraphData = null;
function onSliceGraphUpdate()
{
    if(plot == null) { return; }

    // build data
    let widthSlice = Math.abs(sliceVertices[0].x - sliceVertices[1].x) * canvas.width;
    let heightSlice = Math.abs(sliceVertices[0].y - sliceVertices[1].y) * canvas.height;
    let numSample = Math.floor(widthSlice + heightSlice);
    let distanceSlice = Math.sqrt(widthSlice * widthSlice + heightSlice * heightSlice);

    if( numSample < 5) { return; }

    sliceGraphData = [
        Array(numSample),

        Array(numSample),
        Array(numSample),
        Array(numSample),

        Array(numSample),
        Array(numSample),
        Array(numSample),
    ];
    let oL = {};
    let oR = {};
    for(let i = 0 ; i < numSample ; ++i)
    {
        let amt = i / (numSample - 1);
        let x = distanceSlice * amt;
        sliceGraphData[0][i] = x; // x axis

        let u = lerp(sliceVertices[0].x, sliceVertices[1].x, amt);
        let v = lerp(sliceVertices[0].y, sliceVertices[1].y, amt);

        function cleanF(x) {
            return Number.isFinite(x) ? x : null;
        }
        
        sampleNearestNeighbor(imageLRaw, u, 1.0 - v, oL);
        sliceGraphData[1][i] = cleanF(oL.r);
        sliceGraphData[2][i] = cleanF(oL.g);
        sliceGraphData[3][i] = cleanF(oL.b);

        sampleNearestNeighbor(imageRRaw, u, 1.0 - v, oR);
        sliceGraphData[4][i] = cleanF(oR.r);
        sliceGraphData[5][i] = cleanF(oR.g);
        sliceGraphData[6][i] = cleanF(oR.b);
    }

    let nSeries = plot.series.length;
    for(let i = 0 ; i < nSeries - 1 ; i++)
    {
        plot.delSeries( nSeries - 1 - i );
    }

    let lineDash = [5, 2];
    plot.addSeries({
        value: (self, rawValue) => rawValue.toFixed(3),
        label: "L",
        stroke: "#DD0000",
        dash: lineDash,
    }, 1);
    plot.addSeries({
        value: (self, rawValue) => rawValue.toFixed(3),
        label: "L",
        stroke: "#00DD00",
        dash: lineDash,
    }, 2);
    plot.addSeries({
        value: (self, rawValue) => rawValue.toFixed(3),
        label: "L",
        stroke: "#0000DD",
        dash: lineDash,
    }, 3);
    plot.addSeries({
        value: (self, rawValue) => rawValue.toFixed(3),
        label: "R",
        stroke: "red",
    }, 4);
    plot.addSeries({
        value: (self, rawValue) => rawValue.toFixed(3),
        label: "R",
        stroke: "green",
    }, 5);
    plot.addSeries({
        value: (self, rawValue) => rawValue.toFixed(3),
        label: "R",
        stroke: "blue",
    }, 6);

    plot.setData(sliceGraphData);
}

function makeChart( container ) {
    var loop = 1e4;

    let data = [
        Array(),
        Array(),
    ];

    for (var i = 0; i < loop; i++) {
        let x = 2 * Math.PI * i / loop;
        let y = Math.sin(x);

        data[0][i] = x;
        data[1][i] = y;
    }
    const opts = {
        width: 600,
        height: 400,
        plugins: [
        {
            hooks: {
                setCursor: u => {
                    const { left, top, idx } = u.cursor;
                    if( idx == null )
                    {
                        focusSliceAMT = null;
                    }
                    else
                    {
                        focusSliceAMT = idx / (u.data[0].length - 1);
                    }
                }
            }
        }],
        scales: {
            x: {
                time: false,
            },
            y: {
                auto: false,
                range: [0, 1],
            },
        },
        series: [
            {
                label: "x",
                value: (self, rawValue) => rawValue.toFixed(1),
            },
        ],
    };

    let u = new uPlot( opts, data, container );
    return u;
}
            
function onSliceGraph()
{
    let defaultWidth = 600;
    let defaultHeight = 300;
    $( "#sldialog" ).dialog({
        width: defaultWidth,
        height: defaultHeight,
       open: function (event) {
        //https://stackoverflow.com/questions/1619750/how-can-you-disable-scroll-bars-in-the-jquery-ui-dialog-box
        $('#sldialog').css('overflow', 'hidden'); //Hide Scroll Bar
        // doUpdateSLCanvas();
        isSliceGraphShowing = true;
        invokeRender();

        if( plot == null )
        {
            plot = makeChart( this );
        }
        let d = this;
        setTimeout(function() {
            onSliceGraphUpdate();
        }, 10);
        plot.setSize( {width: defaultWidth, height: defaultHeight - 10 /* fixbias*/ - 80} );
       },
       close: function (event) {
        isSliceGraphShowing = false;
        invokeRender();
       },
       resize: function( event, ui ) {
        plot.setSize( {width: ui.size.width, height: ui.size.height - 80} );
       },
    });
}
// setTimeout(function() {
//     onSliceGraph();
// }, 500);

</script>
</body>
</html>
