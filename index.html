<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
    <title>SimpleImageCompareTool3</title>

    <script src="jquery-3.3.1.min.js"></script>
    <script src="jquery.event.move.js"></script>
    <script src="jquery.knob.js"></script>

    <link rel="stylesheet" href="jquery-ui.min.css">
    <script src="jquery-ui.min.js"></script>

    <script src="GlslCanvas.js"></script>
    <script src="FileSaver.js"></script>
    <script src="paste.js"></script>
    <script src="exrapi_compiled.js"></script>
    
    <link rel="stylesheet" href="huebee.css">
    <script src="huebee.pkgd.js"></script>

    <link rel="stylesheet" href="check.css">
    <link rel="stylesheet" href="slider.css">
    <link rel="stylesheet" href="combo.css">

    <script src="Chart.js"></script>

    <style>
        .dragover {
            background:rgb(193, 225, 255);
        }
        .boxspan {
            display: inline-block;
            width: 100%;
            text-align: center;
            line-height:50px;
        }

        /* disable pixel filter */
        .disablePixelFilter {
            image-rendering: optimizeSpeed;             /* Older versions of FF          */
            image-rendering: -moz-crisp-edges;          /* FF 6.0+                       */
            image-rendering: -webkit-optimize-contrast; /* Safari                        */
            image-rendering: -o-crisp-edges;            /* OS X & Windows Opera (12.02+) */
            image-rendering: pixelated;                 /* Awesome future-browsers       */
            -ms-interpolation-mode: nearest-neighbor;   /* IE                            */
        }

        .ui-dialog-titlebar{
            padding: 0.3rem !important;
            font-size: 0.75rem;
        }
    </style>
</head>

<body>
<div style="margin: 10px;">
    <div style="width: 100%; display: flex; ">
        <div id="drop-zoneL" style="height: 50px; width: 100%; border: thin solid #acacac;  border-radius: 10px;"><span class="boxspan">Left Image (Please drop your image here)</span></div>
        <div style="width: 20px;"></div>
        <div id="drop-zoneR" style="height: 50px; width: 100%; border: thin solid #acacac;  border-radius: 10px;"><span class="boxspan">Right Image (Please drop your image here)</span></div>
    </div>
</div>

<div style="display: flex; justify-content: center; align-items: baseline;" id="glcontainer">
    <canvas id="glcanvas" style="max-width:100%; height:auto;" class="disablePixelFilter">
</div>

<div style="display: flex; justify-content: center; align-items: baseline; position: absolute; left: 0px; top: 0px; z-index: 10;" id="uicontainer">
    <canvas id="uicanvas" style="max-width:100%; height:auto;">
</div>

<style>
.ui_container > div {
    flex-basis: 160px;
    height: 160px;
    margin: 5px;
    padding: 12px;
    background: #ffffff;
    border-radius: 10px;
    box-shadow:0px 1px 0px 1px #d5d5d5;
}
</style>
<div style="margin:20px; padding:10px; background: #ececec; border-radius: 10px;">
    <div style="display: flex; flex-wrap: wrap; " class="ui_container">
        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Direction</div>
            <div id="dial_container">
                <input type="text" value="0" class="direction_dial" data-width="100" data-displayInput=false data-thickness=.5 data-cursor=true>
            </div>
            <select id="fixed_direction" name="fixed_direction">
                <option value="">Free Direction</option>
                <option value="↘">↘</option>
                <option value="↗">↗</option>
                <option value="↖">↖</option>
                <option value="↙">↙</option>
            </select>
        </div>
        
        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Border</div>
            <div style="text-align: center;" id="borderlabel">2 px</div>
            <div style="height: 25px"></div> <!--  margin -->
            <input type="range" value="2" min="0" max="32" step="1" id="border" class="slider">
        </div>

        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Border Color</div>
            <div style="height: 25px"></div> <!--  margin -->
            <input class="border_color" value="#000000" style="width:130px"/>
        </div>

        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Labels</div>
            <div style="height: 25px"></div> <!--  margin -->
            <input value="" style="width:130px" id="Label_L_override"/>
            <div style="height: 10px"></div> <!--  margin -->
            <input value="" style="width:130px" id="Label_R_override"/>
        </div>

        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Font Size</div>
            <div style="text-align: center;" id="fontsizelabel">20 px</div>
            <div style="height: 25px"></div> <!--  margin -->
            <input type="range" value="20" min="0" max="100" step="1" id="fontsize" class="slider">
        </div>

        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Font Color</div>
            <div style="height: 25px"></div> <!--  margin -->
            <input class="font_color" value="#FF0000" style="width:130px"/>
        </div>

        <div style="display: flex; flex-direction:column; align-items: center;" id="fperror">
            <div style="text-align: center;">Floating Point Error</div>
            <div style="height: 15px"></div> <!--  margin -->
            <div style="text-align: center; font-size: 14px;">NaN</div>
            <input class="Nan_Color" value="#FF0000" style="width:130px"/>
            <div style="height: 10px"></div> <!--  margin -->
            <div style="text-align: center; font-size: 14px;">Infinity</div>
            <div style="height: 5px"></div> <!--  margin -->
            <input class="Inf_Color" value="#FF00FF" style="width:130px"/>
        </div>

        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Diff Mode</div>
            <div style="height: 20px"></div> <!--  margin -->
            <div class="onoffswitch">
                <input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="diffmode" onchange="didChangeDiffMode(this.checked)">
                <label class="onoffswitch-label" for="diffmode"></label>
            </div>
            <div style="height: 20px"></div> <!--  margin -->
            <div style="text-align: center; opacity:0.3;" id="diffscalelabel">100 %</div>
            <input type="range" value="100" min="100" max="500" step="1" id="diffscale" style="opacity:0.3;" class="slider">
        </div>

        <style>
            .PasteAreaL:focus-within {
                background:rgb(91, 88, 255);
            }
            .PasteAreaR:focus-within {
                background:rgb(91, 88, 255);
            }
        </style>
        <div style="display: flex; flex-direction:column; align-items: center; ">
            <div style="text-align: center;">Click and Paste L↓</div>
            <div class="PasteAreaL" style="height: 80%; width: 90%; border: thin solid #acacac;"></div>
        </div>
        <div style="display: flex; flex-direction:column; align-items: center; ">
            <div style="text-align: center;">Click and Paste R↓</div>
            <div class="PasteAreaR" style="height: 80%; width: 90%; border: thin solid #acacac;"></div>
        </div>
        
        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Loupe</div>
            <div style="height: 10px"></div> <!--  margin -->
            <div class="onoffswitch">
                <input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="loupeMode" onchange="didChangeLoupeMode(this.checked)">
                <label class="onoffswitch-label" for="loupeMode"></label>
            </div>
            <div style="height: 10px"></div> <!--  margin -->
            <div style="text-align: center; opacity:0.3;" id="loupeSizeLabel">150 px</div>
            <div style="height: 5px"></div> <!--  margin -->
            <input type="range" value="150" min="10" max="500" step="10" id="loupeSize" style="opacity:0.3;" class="slider">
            <div style="height: 10px"></div> <!--  margin -->
            <div style="text-align: center; opacity:0.3;" id="loupeScaleLabel">200 %</div>
            <div style="height: 5px"></div> <!--  margin -->
            <input type="range" value="200" min="100" max="500" step="10" id="loupeScale" style="opacity:0.3;" class="slider">
        </div>

        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Post Process</div>
            <div style="height: 10px"></div> <!--  margin -->
            <div class="onoffswitch">
                <input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="PostProcess" onchange="didChangePostProcess(this.checked)">
                <label class="onoffswitch-label" for="PostProcess"></label>
            </div>
            <div style="height: 10px"></div> <!--  margin -->
            <div style="text-align: center; opacity:0.3;" id="postScaleLabel">100 %</div>
            <div style="height: 10px"></div> <!--  margin -->
            <input type="range" value="100" min="10" max="300" step="10" id="postScale" style="opacity:0.3;" class="slider">
            <div style="height: 22px"></div> <!--  margin -->
            <select id="GammaSelect" style="opacity:0.3;">
                <option value="1.0">Gamma 1.0</option>
                <option value="2.2" selected>Gamma 2.2</option>
                <option value="2.4">Gamma 2.4</option>
            </select>
        </div>

        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Slice Graph</div>
            <div style="height: 10px"></div> <!--  margin -->
            <button style="
                height: 100px;
                width: 100px;
                color: rgb(115, 77, 255);
            " onclick="onSliceGraph()"></button>
        </div>

        <div style="display: flex; flex-direction:column; align-items: center;  margin-left: auto; background-image:url(gradient.png); background-size: 100% 23%; background-repeat: no-repeat;">
            <div style="text-align: center; opacity:0.3;" id="WelchLabel"> Welch (exr only)</div>
            <div style="height: 14px"></div> <!--  margin -->
            <button style="
                background: url('welch.svg') no-repeat center;
                height: 80px;
                width: 80px;
                color: white;
                opacity:0.3;
            " onclick="onWelch()" id="WelchButton"></button>
            <div style="height: 20px"></div> <!--  margin -->
            <input type="range" value="0" min="0" max="100" step="1" id="WelchSlider" style="opacity:0.3;" class="slider">
        </div>
        <div style="display: flex; flex-direction:column; align-items: center; flex-basis: 250px; height: 160px; display: none;" id="pUI">
            <canvas id="wcanvas" style="max-width:100%; height:auto; margin: -6px;"></canvas>
            <!-- background-color: aqua;  -->
        </div>
        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Save</div>
            <div style="height: 10px"></div> <!--  margin -->
            <button style="
                background: url('save.svg') no-repeat center;
                height: 100px;
                width: 100px;
                color: white;
            " onclick="onSave()"></button>
        </div>
    </div>
</div>

<a href="https://github.com/Ushio/SimpleImageCompareTool3">Github Repo</a>

<div hidden>
    <div id="sldialog" title="Slice Graph" style="padding: 0;margin:0">
        <div style="
        background-color: rgb(255, 0, 200);
        top: 0;
        left: 0;
        width: 100%;
        height: 50px;
        ">
        <canvas id="slcanvas" style="
            background-color: aqua;
            /* position: absolute; */
            top: 0;
            left: 0;
            /* width: 100%;
            height: 100%; */
        "> </canvas>
        </div>
    </div>
</div>

<details>
    <summary>Welch Notes</summary>
    <ul>
    <li>Violet is danger area. But all Violet is won't necessarily mean wrong.</li>
    <li>Uniform-distribution of p-value is good. but there are some exceptions on high match tile e.g. EnvMap. it could cause unbalanced distribution. </li>
    <li>You could capture pretty faint errors like this ( metallic parameter 0.00 vs 0.01 )</li>
    </ul>
    
    <img src="welch_example.png"></img>
</details>

<script>
'use strict';
const canvas = document.getElementById('glcanvas');
const glsl = new GlslCanvas(canvas, {preserveDrawingBuffer: true});

const uicanvas = document.getElementById('uicanvas');
const uictx = uicanvas.getContext('2d');
const compositecanvas = document.createElement('canvas');

function invokeRender() {
    glsl.forceRender = true;
    glsl.render();
    glsl.forceRender = false;
}

let L_filename = "L";
let R_filename = "R";

let angle = 0.0; // for label location

const HILIGHT_VALUE = 0.4;

// For welch
var floatImageWidth  = 0;
var floatImageHeight = 0;
var floatImageL = null;
var floatImageR = null;

// for Slice Graph. left to right and top to bottom order.
let imageLRaw = null;
let imageRRaw = null;

// for flexible drop
let glu_directionX = 1;
let glu_directionY = 0;
let glu_direction_fixedX = 0;
let glu_direction_fixedY = 0;
let glu_mouselocationX = canvas.width * 0.5;
let glu_mouselocationY = canvas.height * 0.5;
let mouseLocationXLocalAlways = 0;
let mouseLocationYLocalAlways = 0;

glsl.on("render", function(e) {
    const glcontainer = $('#glcontainer');
    var offset = glcontainer.offset();

    $('#uicontainer')
        .css('left', offset.left)
        .css('top', offset.top)
        .width (glcontainer.width())
        .height(glcontainer.height());

    uicanvas.width  = canvas.width;
    uicanvas.height = canvas.height;
    
    const fontsize = $("#fontsize")[0].value;
    const font_color = $(".font_color")[0].value;
    const TEXT_MARGIN = 15;

    const Location = {
        LT : 1,
        RT : 2,
        LB : 3,
        RB : 4
    };
    function drawText(text, location) {
        if(fontsize == "0") {
            return;
        }
        uictx.save();
        uictx.font = fontsize + "px Arial";
        uictx.fillStyle = font_color;
        uictx.strokeStyle = "white";

        uictx.lineWidth = parseFloat(fontsize) / 6.0;
        uictx.lineJoin = "round";
        
        let x, y;
        if(location == Location.LT || location == Location.RT){
            uictx.textBaseline = "top";
            y = TEXT_MARGIN;
        } else {
            uictx.textBaseline = "bottom";
            y = uicanvas.height - TEXT_MARGIN;
        }
        if(location == Location.LT || location == Location.LB){
            uictx.textAlign = "left";
            x = TEXT_MARGIN;
        } else {
            uictx.textAlign = "right";
            x = uicanvas.width - TEXT_MARGIN;
        }
        
        uictx.strokeText(text, x, y);
        uictx.fillText(text, x, y);
        uictx.restore();
    }

    let label_L = $("#Label_L_override")[0].value || L_filename;
    let label_R = $("#Label_R_override")[0].value || R_filename;

    const fixed_direction = $('[name="fixed_direction"] option:selected').val();
    if(fixed_direction) {
        // fixed label
        if(fixed_direction === "↘") {
            drawText(label_L, Location.LT);
            drawText(label_R, Location.RB);
        }
        if(fixed_direction === "↗") {
            drawText(label_L, Location.LB);
            drawText(label_R, Location.RT);
        }
        if(fixed_direction === "↖") {
            drawText(label_L, Location.RB);
            drawText(label_R, Location.LT);
        }
        if(fixed_direction === "↙") {
            drawText(label_L, Location.RT);
            drawText(label_R, Location.LB);
        }
    } else {
        // automatic
        if(angle < -135.0) {
            drawText(label_L, Location.RT);
            drawText(label_R, Location.LT);
        }
        else if(-135.0 <= angle && angle < -95.0) {
            drawText(label_L, Location.RT);
            drawText(label_R, Location.LB);
        }
        else if(-95.0 <= angle && angle < -85.0) {
            drawText(label_L, Location.LT);
            drawText(label_R, Location.LB);
        }
        else if(-85.0 <= angle && angle < -45.0) {
            drawText(label_L, Location.LT);
            drawText(label_R, Location.RB);
        }
        else if(-45.0 <= angle && angle < 45.0) {
            drawText(label_L, Location.LT);
            drawText(label_R, Location.RT);
        } else if(45.0 <= angle && angle < 85.0) {
            drawText(label_L, Location.LB);
            drawText(label_R, Location.RT);
        } else if(85.0 <= angle && angle < 95.0) {
            drawText(label_L, Location.LB);
            drawText(label_R, Location.LT);
        } else if(95.0 <= angle && angle < 135.0) {
            drawText(label_L, Location.RB);
            drawText(label_R, Location.LT);
        }
        else if(135.0 <= angle && angle <= 180.0) {
            drawText(label_L, Location.RT);
            drawText(label_R, Location.LT);
        }
    }
    
    // uictx.fillRect(mouseLocationXLocalAlways, uicanvas.height - 1 - mouseLocationYLocalAlways, 10, 10);
});

// UI Drawing
// setInterval(function () {
// }, 
// 100);

$(window).resize(invokeRender);

// we don't need auto rendering loop
glsl.pause();

// Load only the Fragment Shader
var fs = `
#extension GL_OES_standard_derivatives : enable
#ifdef GL_ES
precision mediump float;
#endif
    uniform vec2  u_resolution;
    uniform vec2  u_mouselocation;
    uniform vec2  u_direction;
    uniform vec2  u_direction_fixed;
    uniform float u_border;
    uniform vec3  u_border_color;
    uniform float u_diffmode;
    uniform float u_diffscale;

    uniform float u_loupemode;
    uniform float u_loupeSize;
    uniform float u_loupeScale;

    uniform float u_postProcess;
    uniform float u_postScale;
    uniform float u_postGamma;

    uniform float u_welchOverlay;

    uniform float u_hilightL;
    uniform float u_hilightR;

    uniform sampler2D u_image_L;
    uniform sampler2D u_image_R;
    uniform sampler2D u_image_welch;

    uniform vec3 u_Nan_Color;
    uniform vec3 u_Inf_Color;
    
    float border(vec2 fragcood, vec2 n, vec2 p) {
        float base = dot(p,        n);
        float x    = dot(fragcood, n);
        return x - base;
    }

    vec4 applyPost(vec4 c)
    {
        if( u_postProcess != 0.0 )
        {
            c.x = pow(u_postScale * c.x, 1.0 / u_postGamma);
            c.y = pow(u_postScale * c.y, 1.0 / u_postGamma);
            c.z = pow(u_postScale * c.z, 1.0 / u_postGamma);
        }
        return c;
    }

    // https://stackoverflow.com/questions/11810158/how-to-deal-with-nan-or-inf-in-opengl-es-2-0-shaders
    bool isnan( float val )
    {
        return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true;
    }
    #define FLT_MAX 3.402823466e+38
    bool isinf(float n) 
    {
        return FLT_MAX < abs(n);
    }
    vec4 GetImageL(vec2 st)
    {
        vec4 c = texture2D(u_image_L, st);

        if(isnan(c.x) || isnan(c.y) || isnan(c.z) || isnan(c.w)) {
            c = vec4(u_Nan_Color, 1.0);
        } else if( isinf(c.x) || isinf(c.y) || isinf(c.z) || isinf(c.w) ) {
            c = vec4(u_Inf_Color, 1.0);
        }
        return c;
    }
    vec4 GetImageR(vec2 st)
    {
        vec4 c = texture2D(u_image_R, st);
        if(isnan(c.x) || isnan(c.y) || isnan(c.z) || isnan(c.w)) {
            c = vec4(u_Nan_Color, 1.0);
        } else if( isinf(c.x) || isinf(c.y) || isinf(c.z) || isinf(c.w) ) {
            c = vec4(u_Inf_Color, 1.0);
        }
        return c;
    }
    vec4 addHilightL(vec4 c)
    {
        return mix(c, vec4(1.0), u_hilightL);
    }
    vec4 addHilightR(vec4 c)
    {
        return mix(c, vec4(1.0), u_hilightR);
    }

    void main() {
        vec2 fragcoord = gl_FragCoord.xy;
        vec2 st = fragcoord / u_resolution.xy;

        vec4 L = GetImageL(st);
        vec4 R = GetImageR(st);

        if(0.0 < u_diffmode) {
            L = abs(L - R) * u_diffscale;
        }

        L = addHilightL(L);
        R = addHilightR(R);

        if(0.1 < mod(u_border, 2.0)) {
            fragcoord += vec2(0.5);
        }

        // 
        vec2 direction = 0.0 < length(u_direction_fixed) ? u_direction_fixed : u_direction;
        
        float b = border(fragcoord, direction, u_mouselocation);

        bool is_straight = abs(direction.x) < 1.0e-5 || abs(direction.y) < 1.0e-5;
        float delta = is_straight ? 0.0 : 0.9 /* feeling constant */;

        float s = smoothstep(-delta, delta, b);

        gl_FragColor = mix(L, R, s);
        
        // Loupe
        float loupedelta = 0.9; 
        if(0.0 < u_loupemode)
        {
            float size = u_loupeSize;
            float scale = u_loupeScale;
            
            // center of loupe
            vec2 lhs = u_mouselocation - direction * size * 0.6 /*bias*/;
            {
                float alpha = 1.0 - smoothstep( size * 0.5 - loupedelta, size * 0.5 + loupedelta, distance(fragcoord, lhs) );
                vec2 localcoord = fragcoord - lhs;
                vec2 sample = (localcoord / scale + u_mouselocation)  / u_resolution.xy;
                gl_FragColor.rgb = mix(gl_FragColor.rgb, GetImageL(sample).rgb, alpha);
            }

            // center of loupe
            vec2 rhs = u_mouselocation + direction * size * 0.6 /*bias*/;
            {
                float alpha = 1.0 - smoothstep( size * 0.5 - loupedelta, size * 0.5 + loupedelta, distance(fragcoord, rhs) );
                vec2 localcoord = fragcoord - rhs;
                vec2 sample = (localcoord / scale + u_mouselocation)  / u_resolution.xy;
                gl_FragColor.rgb = mix(gl_FragColor.rgb, GetImageR(sample).rgb, alpha);
            }

            gl_FragColor = applyPost(gl_FragColor);

            if( 0.0 < u_border ) {
                float a = smoothstep(u_border * 0.5 - loupedelta, u_border * 0.5 + loupedelta, abs(distance(fragcoord, lhs) - size * 0.5));
                float b = smoothstep(u_border * 0.5 - loupedelta, u_border * 0.5 + loupedelta, abs(distance(fragcoord, rhs) - size * 0.5));
                gl_FragColor.rgb = mix(u_border_color, gl_FragColor.rgb, a * b);
            }
        }
        else
        {
            gl_FragColor = applyPost(gl_FragColor);
        }

        if(0.0 < u_border) {
            float bar = u_border * 0.5;
            float bar_window = smoothstep(bar - delta, bar + delta, abs(b));
            gl_FragColor.rgb = mix(u_border_color, gl_FragColor.rgb, bar_window);
        }

        // welch
        if( 0.0 < u_welchOverlay )
        {
            vec3 welch = texture2D( u_image_welch, st ).rgb;
            gl_FragColor.rgb = mix( gl_FragColor.rgb, welch, u_welchOverlay );
        }
        
        gl_FragColor.a = 1.0;
    }
`;
glsl.load(fs);

canvas.width = 1200;
canvas.height = 722;

L_filename = "dogs-before";
R_filename = "dogs-after";
$('#Label_L_override').attr("placeholder", L_filename);
$('#Label_R_override').attr("placeholder", R_filename);

// Default Values
glsl.setUniform("u_image_L", "dogs-before.jpg");
glsl.setUniform("u_image_R", "dogs-after.jpg");
glsl.setUniform("u_direction", 1.0, 0.0);
glsl.setUniform("u_mouselocation", canvas.width * 0.5, canvas.height * 0.5);
glsl.setUniform("u_border", 2);
glsl.setUniform("u_border_color", 0.0, 0.0, 0.0);
glsl.setUniform("u_diffmode", 0.0);
glsl.setUniform("u_diffscale", 1.0);
glsl.setUniform("u_direction_fixed", 0.0, 0.0);
glsl.setUniform("u_loupeMode", 0.0);
glsl.setUniform("u_loupeSize", 150.0);
glsl.setUniform("u_loupeScale", 2.0);
glsl.setUniform("u_postProcess", 0.0);
glsl.setUniform("u_postScale", 1.0);
glsl.setUniform("u_postGamma", 2.2);
glsl.setUniform("u_welchOverlay", 0.0);
glsl.setUniform("u_hilightL", 0.0);
glsl.setUniform("u_hilightR", 0.0);
glsl.setUniform("u_Nan_Color", 1.0, 0.0, 0.0);
glsl.setUniform("u_Inf_Color", 1.0, 0.0, 1.0);
{
    let nPixels = 2 * 2;
    let rgba = new Float32Array(nPixels * 4);
    for (let i = 0; i < nPixels; i++) {
        rgba[i * 4 + 0] = 1.0;
        rgba[i * 4 + 1] = 1.0;
        rgba[i * 4 + 2] = 1.0;
        rgba[i * 4 + 3] = 1.0;
    }
    glsl.setUniform("u_image_welch", { width:2, height:2, data:rgba });
}

// Mouse Move & Mouse Up is need global event  -> html
// Mouse Down shouldn't work outside of canvas -> EVENT_VIEW
const EVENT_VIEW = "#uicanvas";

var down = false;
$(EVENT_VIEW).mousedown(function(e) {
    down = true;
});
$("html").mouseup(function() {
    down = false;
});

function updateMouseLocation(e) {
    {
        // Coordinate transform
        // https://qiita.com/yukiB/items/cc533fbbf3bb8372a924#2-jquery%E3%81%AEoffset%E3%81%A8eventpagexy%E3%82%92%E4%BD%BF%E7%94%A8
        const offset = $('#glcanvas').offset();
        const x = e.pageX - offset.left;
        const y = e.pageY - offset.top;
        e.offsetX = x;
        e.offsetY = y;
    }
    const scale = canvas.width / canvas.clientWidth;
    const x = e.offsetX * scale;
    const y = canvas.height - e.offsetY * scale;
    if(down) {
        glu_mouselocationX = x;
        glu_mouselocationY = y;
        glsl.setUniform("u_mouselocation", Math.round(x), Math.round(y));
    }
    mouseLocationXLocalAlways = x;
    mouseLocationYLocalAlways = y;
}

$("html").mousemove(function(e) {
    updateMouseLocation(e);
    
    // disable drag selection effects.
    const uidialog = $('.ui-dialog');
    if (0 < uidialog.length && uidialog.is(':hover')) {
        e.preventDefault();
    }
});
$(EVENT_VIEW).mouseleave(updateMouseLocation);
$(EVENT_VIEW).mousedown(function(e){
    down = true;
    updateMouseLocation(e);
});

// Direction
const DIAL_STEPS = 100.0;
$(".direction_dial").attr("value", DIAL_STEPS / 4).knob({
    'max' : DIAL_STEPS,
    'height' : 110,
    'fgColor' : "#2A2A2A",
    'change' : function (v) { 
        const clock = this.cv;
        const tick = (clock - DIAL_STEPS / 4.0);
        const radian = -tick / DIAL_STEPS * Math.PI * 2;
        angle = radian / (2.0 * Math.PI) * 360.0;
        if(angle <= -180.0) {
            angle += 360.0;
        }
        glu_directionX = Math.cos(radian);
        glu_directionY = Math.sin(radian);
        glsl.setUniform("u_direction", glu_directionX, glu_directionY);
        
        // move to free mode
        $('#fixed_direction').val("");
        $("#dial_container").css("opacity", 1.0);

        glu_direction_fixedX = 0;
        glu_direction_fixedY = 0;
        glsl.setUniform("u_direction_fixed", glu_direction_fixedX, glu_direction_fixedY);
    }
});

$("#fixed_direction").on("change", function(e){
    const value = this.value;
    if(value) {
        $("#dial_container").css("opacity", 0.3);
        glu_mouselocationX = canvas.width * 0.5;
        glu_mouselocationY = canvas.height * 0.5;
        glsl.setUniform("u_mouselocation", glu_mouselocationX , glu_mouselocationY);

        const L = Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height);
        if(value === "↘") {
            glu_direction_fixedX = canvas.height / L;
            glu_direction_fixedY = -canvas.width / L;
        }
        if(value === "↗") {
            glu_direction_fixedX = canvas.height / L;
            glu_direction_fixedY = canvas.width / L;
        }
        if(value === "↖") {
            glu_direction_fixedX = -canvas.height / L;
            glu_direction_fixedY = canvas.width / L;
        }
        if(value === "↙") {
            glu_direction_fixedX = -canvas.height / L;
            glu_direction_fixedY = -canvas.width / L;
        }
    } else {
        glu_direction_fixedX = 0;
        glu_direction_fixedY = 0;
        $("#dial_container").css("opacity", 1.0);
    }
    glsl.setUniform("u_direction_fixed", glu_direction_fixedX, glu_direction_fixedY);
    invokeRender();
});

// Border
$("#border").on("input", function(e){
    const value = this.value;
    glsl.setUniform("u_border", parseFloat(value));
    $("#borderlabel").text(value + "px");
});

// Border color
var hueb_border = new Huebee( '.border_color', {
  notation: 'hex',
  saturations: 2,
});
hueb_border.on( 'change', function( color, hue, sat, lum ) {
    const R = color.slice(1, 3);
    const G = color.slice(3, 5);
    const B = color.slice(5, 7);
    const r = parseInt(R, 16) / 255.0;
    const g = parseInt(G, 16) / 255.0;
    const b = parseInt(B, 16) / 255.0;
    glsl.setUniform("u_border_color", r, g, b);
});

$('#Label_L_override').on('input', function () {
    invokeRender();
});
$('#Label_R_override').on('input', function () {
    invokeRender();
});

$("#fontsize").on("input", function(e){
    const value = this.value;
    invokeRender();
    $("#fontsizelabel").text(value + "px");
});
// from URL Params
const url = new URL(location);
const fontsize = url.searchParams.get('fontsize');
if(fontsize) {
    $("#fontsize").val(fontsize);
    $("#fontsizelabel").text(fontsize + "px");
}

var hueb_font = new Huebee( '.font_color', {
  notation: 'hex',
  saturations: 2,
});
hueb_font.on( 'change', function( color, hue, sat, lum ) {
    const R = color.slice(1, 3);
    const G = color.slice(3, 5);
    const B = color.slice(5, 7);
    const r = parseInt(R, 16) / 255.0;
    const g = parseInt(G, 16) / 255.0;
    const b = parseInt(B, 16) / 255.0;
    invokeRender();
});

var hueb_Nan_Color = new Huebee( '.Nan_Color', {
  notation: 'hex',
  saturations: 2,
});
hueb_Nan_Color.on( 'change', function( color, hue, sat, lum ) {
    const R = color.slice(1, 3);
    const G = color.slice(3, 5);
    const B = color.slice(5, 7);
    const r = parseInt(R, 16) / 255.0;
    const g = parseInt(G, 16) / 255.0;
    const b = parseInt(B, 16) / 255.0;
    glsl.setUniform("u_Nan_Color", r, g, b);
});

var hueb_Inf_Color = new Huebee( '.Inf_Color', {
  notation: 'hex',
  saturations: 2,
});
hueb_Inf_Color.on( 'change', function( color, hue, sat, lum ) {
    const R = color.slice(1, 3);
    const G = color.slice(3, 5);
    const B = color.slice(5, 7);
    const r = parseInt(R, 16) / 255.0;
    const g = parseInt(G, 16) / 255.0;
    const b = parseInt(B, 16) / 255.0;
    glsl.setUniform("u_Inf_Color", r, g, b);
});

function didChangeDiffMode(value) {
    glsl.setUniform("u_diffmode", value ? 1.0 : 0.0);
    const op = value ? 1.0 : 0.3;
    $("#diffscalelabel").css("opacity", op);
    $("#diffscale").css("opacity", op);
}
// Border
$("#diffscale").on("input", function(e) {
    const value = this.value;
    const scale = parseFloat(value) / 100.0;
    glsl.setUniform("u_diffscale", scale);
    $("#diffscalelabel").text(value + " %");
});

// paste
function imagePaste(sampler, dataURL) {
    glsl.setUniform(sampler, null);
    glsl.setUniform(sampler, dataURL);

    const image = new Image();
    image.onload = function() {
        canvas.width = image.width;
        canvas.height = image.height;
    };
    image.src = dataURL;
}

$('.PasteAreaL').pastableNonInputable();
$('.PasteAreaL').on('pasteImage', function(ev, data) {
    L_filename = "clipboard L";
    updatePlaceHolder();
    imagePaste("u_image_L", data.dataURL);
});
$('.PasteAreaR').pastableNonInputable();
$('.PasteAreaR').on('pasteImage', function(ev, data) {
    R_filename = "clipboard R";
    updatePlaceHolder();
    imagePaste("u_image_R", data.dataURL);
});

function didChangeLoupeMode(value) {
    glsl.setUniform("u_loupemode", value ? 1.0 : 0.0);
    const op = value ? 1.0 : 0.3;
    $("#loupeSizeLabel").css("opacity", op);
    $("#loupeSize").css("opacity", op);

    $("#loupeScaleLabel").css("opacity", op);
    $("#loupeScale").css("opacity", op);
}
function didChangePostProcess(value) {
    glsl.setUniform("u_postProcess", value ? 1.0 : 0.0);
    const op = value ? 1.0 : 0.3;
    $("#postScaleLabel").css("opacity", op);
    $("#postScale").css("opacity", op);
    $("#GammaSelect").css("opacity", op);
}

$("#loupeSize").on("input", function(e) {
    const value = this.value;
    const size = parseFloat(value);
    glsl.setUniform("u_loupeSize", size);
    $("#loupeSizeLabel").text(size + " px");
});
$("#loupeScale").on("input", function(e) {
    const value = this.value;
    const scale = parseFloat(value) / 100.0;
    glsl.setUniform("u_loupeScale", scale);
    $("#loupeScaleLabel").text(value + " %");
});

$("#postScale").on("input", function(e) {
    const value = this.value;
    const scale = parseFloat(value) / 100.0;
    glsl.setUniform("u_postScale", scale);
    $("#postScaleLabel").text(value + " %");
});
$("#GammaSelect").change(function() {
    let value = $(this).val();
    glsl.setUniform("u_postGamma", parseFloat(value));
});

$("#WelchSlider").on("input", function(e) {
    const value = this.value;
    const scale = parseFloat(value) / 100.0;
    glsl.setUniform("u_welchOverlay", scale);
});


// on save
function onSave() {
    compositecanvas.width = canvas.width;
    compositecanvas.height = canvas.height;
    const compositecanvasCtx = compositecanvas.getContext('2d');
    compositecanvasCtx.drawImage(canvas, 0, 0);
    compositecanvasCtx.drawImage(uicanvas, 0, 0);

    var imgdata = compositecanvas.toDataURL('image/png');
    saveAs(imgdata, "compare.png");
}

// function onDebug() {
//     glsl.setUniform("u_image_L", null);

//     let raw = new Uint8Array([
//         0, 0, 0, 255, 
//         255, 0, 0, 255,
//         0, 255, 0, 255,
//         0, 0, 255, 255]);
//     let rawf = new Float32Array([
//         0, 0, 0, 1.0, 
//         Math.random(), 0.5, 0, 1.0,
//         0, 1.0, 0.5, 1.0,
//         0.5, 0, 1.0, 1.0,
    
//         Math.random(), Math.random(), Math.random(), 1.0,
//         Math.random(), Math.random(), Math.random(), 1.0]
//     );
//     glsl.setUniform("u_image_L", { width:2, height:3, data:rawf });
// }

var dragoverHandler = function(e){
    e.preventDefault();
    $(this).addClass("dragover");

    let objectID = $(this).attr("id");
    if(objectID === "drop-zoneL")
    {
        glsl.setUniform("u_hilightL", HILIGHT_VALUE);
    }
    else if(objectID == "drop-zoneR")
    {
        glsl.setUniform("u_hilightR", HILIGHT_VALUE);
    }
};
$("#drop-zoneL").on("dragover", dragoverHandler);
$("#drop-zoneR").on("dragover", dragoverHandler);

var dragleaveHandler = function(e){
    e.preventDefault();
    $(this).removeClass("dragover");

    let objectID = $(this).attr("id");
    if(objectID === "drop-zoneL")
    {
        glsl.setUniform("u_hilightL", 0);
    }
    else if(objectID == "drop-zoneR")
    {
        glsl.setUniform("u_hilightR", 0);
    }
};
$("#drop-zoneL").on("dragleave", dragleaveHandler);
$("#drop-zoneR").on("dragleave", dragleaveHandler);

function rmExt(s) {
    return s.replace(/\.[^/.]+$/, "");
}
function updatePlaceHolder() {
    $('#Label_L_override').attr("placeholder", L_filename);
    $('#Label_R_override').attr("placeholder", R_filename);
}
var handleDrop = function(file, sampler, isLeft) {
    if(isLeft) {
        L_filename = rmExt(file.name);
    } else {
        R_filename = rmExt(file.name);
    }
    updatePlaceHolder();

    let isExr = file.name.endsWith('.exr');

    let reader = new FileReader();
    reader.onload = function(event) {
        glsl.setUniform(sampler, null);

        if(isExr)
        {
            window.loadExr( event.target.result, function(exrImage) {
                console.log(exrImage.width, exrImage.height);

                let channels = exrImage.channels();
                console.log(channels);
                
                let r = null;
                let g = null;
                let b = null;
                for(let i = 0 ; i < channels.length ; i++)
                {
                    let ch = channels[i];
                    let chlower = ch.toLowerCase();
                    if(chlower.endsWith('r'))
                    {
                        r = exrImage.plane(ch);
                    }
                    else if(chlower.endsWith('g'))
                    {
                        g = exrImage.plane(ch);
                    }
                    else if(chlower.endsWith('b'))
                    {
                        b = exrImage.plane(ch);
                    }
                }

                let nPixels = exrImage.width * exrImage.height;
                let rgba = new Float32Array(nPixels * 4);
                for (let i = 0; i < nPixels; i++) {
                    let rval = r != null ? r[i] : 0.0;
                    let gval = g != null ? g[i] : 0.0;
                    let bval = b != null ? b[i] : 0.0;
                    rgba[i * 4 + 0] = rval;
                    rgba[i * 4 + 1] = gval;
                    rgba[i * 4 + 2] = bval;
                    rgba[i * 4 + 3] = 1.0;
                }

                glsl.setUniform(sampler, { width:exrImage.width, height:exrImage.height, data:rgba });

                canvas.width = exrImage.width;
                canvas.height = exrImage.height;

                if(isLeft)
                {
                    floatImageL = rgba;
                }
                else
                {
                    floatImageR = rgba;
                }
                floatImageWidth = exrImage.width;
                floatImageHeight = exrImage.height;

                onTriggeredUpdateImage();
            } );
        }
        else
        {
            glsl.setUniform(sampler, event.target.result);
            const image = new Image();
            image.onload = function() {
                canvas.width = image.width;
                canvas.height = image.height;
            };
            image.src = event.target.result;

            if(isLeft)
            {
                floatImageL = null;
            }
            else
            {
                floatImageR = null;
            }
            floatImageWidth = 0;
            floatImageHeight = 0;

            onTriggeredUpdateImage();
        }
    }
    
    if(isExr)
    {
        reader.readAsArrayBuffer(file);
    }
    else
    {
        reader.readAsDataURL(file);
    }
};
$("#drop-zoneL").on("drop", function(e) {
    e.preventDefault();
    $(this).removeClass("dragover");
    if(0 < e.originalEvent.dataTransfer.files.length)
    {
        handleDrop(e.originalEvent.dataTransfer.files[0], "u_image_L", true);
    }

    glsl.setUniform("u_hilightL", 0);
    glsl.setUniform("u_hilightR", 0);
});
$("#drop-zoneR").on("drop", function(e) {
    e.preventDefault();
    $(this).removeClass("dragover");
    if(0 < e.originalEvent.dataTransfer.files.length)
    {
        handleDrop(e.originalEvent.dataTransfer.files[0], "u_image_R", false);
    }

    glsl.setUniform("u_hilightL", 0);
    glsl.setUniform("u_hilightR", 0);
});

function sqr(x) { return x * x; }
function mouseBorder()
{
    const useFixed = 0.0 < (sqr(glu_direction_fixedX) + sqr(glu_direction_fixedY));
    let dirX = useFixed ? glu_direction_fixedX : glu_directionX;
    let dirY = useFixed ? glu_direction_fixedY : glu_directionY;
    let base = glu_mouselocationX * dirX + glu_mouselocationY * dirY;
    let x    = mouseLocationXLocalAlways * dirX + mouseLocationYLocalAlways * dirY;
    let border = x - base;
    return border; 
}


$(document).on('dragover drop', function (e) {
    // update location for drag and drop
    updateMouseLocation(e);

    // ignore drop outside of the drop area.
    e.stopPropagation();
    e.preventDefault();
    
    return false;
});

// Control hilight
$("#uicanvas").on('dragover', function (e) {
    let border = mouseBorder();
    // console.log(border);
    if(border < 0.0)
    {
        glsl.setUniform("u_hilightL", HILIGHT_VALUE);
        glsl.setUniform("u_hilightR", 0.0);
    }
    else
    {
        glsl.setUniform("u_hilightL", 0);
        glsl.setUniform("u_hilightR", HILIGHT_VALUE);
    }
    
    e.preventDefault();
});

$("#uicanvas").on('drop', function (e) {
    if(0 < e.originalEvent.dataTransfer.files.length)
    {
        let border = mouseBorder();
        if(border < 0.0)
        {
            handleDrop(e.originalEvent.dataTransfer.files[0], "u_image_L", true);
        }
        else
        {
            handleDrop(e.originalEvent.dataTransfer.files[0], "u_image_R", false);
        }
    }

    glsl.setUniform("u_hilightL", 0);
    glsl.setUniform("u_hilightR", 0);
    
    e.stopPropagation();
    e.preventDefault();
});
$("#uicanvas").on("dragleave", function (e) {
    glsl.setUniform("u_hilightL", 0);
    glsl.setUniform("u_hilightR", 0);
    updateMouseLocation(e);
});

$("#drop-zoneL").on("click", function(e) {
    const input = document.createElement('input');
    input.type = 'file';
    input.onchange = event => { 
        handleDrop(event.target.files[0], "u_image_L", true);
    };
    input.click();
});
$("#drop-zoneR").on("click", function(e) {
    const input = document.createElement('input');
    input.type = 'file';
    input.onchange = event => { 
        handleDrop(event.target.files[0], "u_image_R", false);
    };
    input.click();
});

function avariableWelch()
{
    if( floatImageWidth !== 0 && floatImageHeight !== 0 && floatImageL !== null && floatImageR !== null && floatImageL.length === floatImageR.length )
    {
        return true;
    }
    return false;
}

function updateWelchUI()
{
    var enable = avariableWelch();
    const op = enable ? 1.0 : 0.3;
    $("#WelchLabel").css("opacity", op);
    $("#WelchButton").css("opacity", op);
    $("#WelchSlider").css("opacity", op);
}
setInterval("updateWelchUI()", 500); 

class OnlineVariance {
    constructor() {
        this._count = 0;
        this._mean = 0;
        this._M2 = 0;
    }
    addSample( newValue ) {
        this._count++;
        let delta = newValue - this._mean;
        this._mean += delta / this._count;
        let delta2 = newValue - this._mean;
        this._M2 += delta * delta2;
    }
    mean() {
        return this._mean;
    }
    sampleVariance() {
        if (this._count == 0)
        {
            return 0.0;
        }
        return this._M2 / this._count;
    }
    unbiasedVariance()  {
        if (this._count === 0)
        {
            return 0.0;
        }
        return this._M2 / (this._count - 1);
    }
    sampleCount() {
        return this._count;
    }
}
function sqr(x) {
    return x * x;
}
function gauss_Pnu(t)
{
    let tt = t > 0 ? t : -t;
    tt = tt / Math.sqrt(2.0);

    const x = 1.0 / (1.0 + 0.47047 * tt);
    const erf = 1.0 - x * (0.3480242
        + x * (-0.0958798
            + 0.7478556 * x))
        * Math.exp(-tt * tt);
    return 1.0 - erf;
}
// color coding
// input float between 0 and 1
// output colour ramp
function viridis_quintic( x )     
{
    x = Math.min(1.0, x);
    const x2 = x * x;
    const x3 = x2 * x;
    const x4 = x2 * x2;
    const x5 = x3 * x2;
    let col = [0.0, 0.0, 0.0];
    col[0] = +0.280268003 - 0.143510503 * x + 2.225793877 * x2 - 14.815088879 * x3 + 25.212752309 * x4 - 11.772589584 * x5;
    col[1] = -0.002117546 + 1.617109353 * x - 1.909305070 * x2 + 2.701152864 * x3 - 1.685288385 * x4 + 0.178738871 * x5;
    col[2] = +0.300805501 + 2.614650302 * x - 12.019139090 * x2 + 28.933559110 * x3 - 33.491294770 * x4 + 13.762053843 * x5;
    return col;
}

let pHistgram = [];

const wcanvas = document.getElementById('wcanvas');
wcanvas.width = 300;
wcanvas.height = 215;
const wctx = wcanvas.getContext('2d');

function toFixed(value, precision) {
    var power = Math.pow(10, precision || 0);
    return String(Math.round(value * power) / power);
}
let labels = []
for(let i = 0 ; i < 10 ; i++)
{
    labels.push(toFixed(i / 10.0, 2) + "-" + toFixed((i + 1) / 10.0, 2) );
    // pHistgram.push(Math.random() * 100.0);
    pHistgram.push(0);
}
Chart.defaults.global.animation.duration = 300;
let chart = new Chart(wctx, {
    type: 'horizontalBar',
    data: {
        labels: labels,
        datasets: [{
            label: 'p Value Histgram',
            backgroundColor: 'rgb(255, 99, 132)',
            borderColor: 'rgb(255, 99, 132)',
            data: pHistgram
        }]
    },

    // Configuration options go here
    options: {
        scales: {
            xAxes: [{
                ticks: {
                    beginAtZero: true
                }
            }]
        },
        responsive: true, 
        maintainAspectRatio: false
    }
});

function onWelch()
{
    if( avariableWelch() )
    {
        // ok
    }
    else
    {
        return;
    }

    let onlineVar = new OnlineVariance();
    onlineVar.addSample(1);
    onlineVar.addSample(3);
    onlineVar.addSample(4);

    let tileSize = 30;
    let tileCountX = Math.floor(floatImageWidth / tileSize);
    let tileCountY = Math.floor(floatImageHeight / tileSize);

    let nPixels = floatImageWidth * floatImageHeight;
    let rgba = new Float32Array(nPixels * 4);

    for(let i = 0 ; i < 10 ; ++i)
    {
        pHistgram[i] = 0;
    }

    for (let yi = 0; yi < tileCountY; ++yi)
    {
        for (let xi = 0; xi < tileCountX; ++xi)
        {
            let minP = 1.0;

            // per compornent
            for(let i = 0 ; i < 3 ; ++i)
            {
                let va1 = new OnlineVariance();
                let va2 = new OnlineVariance();
                for(let y = 0; y < tileSize; ++y)
                {
                    for (let x = 0; x < tileSize; ++x)
                    {
                        let sX = xi * tileSize + x;
                        let sY = yi * tileSize + y;
                        let sIndex = sY * floatImageWidth + sX;
                        va1.addSample( floatImageL[sIndex * 4 + i] );
                        va2.addSample( floatImageR[sIndex * 4 + i] );
                    }
                }

                let SEwSquared =
                    va1.unbiasedVariance() / va1.sampleCount()
                    +
                    va2.unbiasedVariance() / va2.sampleCount();
                let SEw = Math.sqrt( SEwSquared );

                // final p value
                let p;

                if ( SEw < Number.EPSILON )
                {
                    p = 1.0;
                }
                else
                {
                    // t value
                    let t = ( va1.mean() - va2.mean() ) / SEw;

                    // TODO 
                    // Degree of Freedom
                    // let nuf =
                    //     sqr(SEwSquared) /
                    //     (
                    //         sqr( va1.unbiasedVariance() ) / ( sqr( va1.sampleCount() ) * ( va1.sampleCount() - 1 ) )
                    //         +                                      
                    //         sqr( va2.unbiasedVariance() ) / ( sqr( va2.sampleCount() ) * ( va2.sampleCount() - 1 ) )
                    //     );
                    // let nu = Math.round( nuf );
                    // console.log(nu);

                    // if( nu < 20 )
                    // {
                    //     p = 2.f * t_Pnu_half(-std::fabs(t), nu );
                    // }
                    // else
                    // {
                    //     p = gauss_Pnu( t );
                    // }

                    p = gauss_Pnu( t );
                    
                    // calc histgram
                    const index = Math.min(Math.floor(p * 10.0), 9);
                    // console.log(p + "/" + index);
                    pHistgram[index]++;
                }

                minP = Math.min(minP, p);
            }

            // glm::vec3 color;
            // viridis_quintic(p, glm::value_ptr(color));
            // pImage(xi, yi) = glm::vec4(color, 1.0f);
            var color = viridis_quintic( minP );
            // let mean = va1.mean();
            for(let y = 0; y < tileSize; ++y)
            {
                for (let x = 0; x < tileSize; ++x)
                {
                    let sX = xi * tileSize + x;
                    let sY = yi * tileSize + y;
                    let dIndex = sY * floatImageWidth + sX;
                    rgba[dIndex * 4]   = color[0];
                    rgba[dIndex * 4+1] = color[1];
                    rgba[dIndex * 4+2] = color[2];
                    rgba[dIndex * 4+3] = 1.0;
                }
            }
        }
    }

    // console.log(pHistgram);
    chart.update();

    glsl.setUniform("u_image_welch", { width:floatImageWidth, height:floatImageHeight, data:rgba });

    $("#WelchSlider").val(100);
    glsl.setUniform("u_welchOverlay", 1.0);
    $("#pUI").show();
}

function downloadTextureAsFloat(image)
{
    // the image might have float array already.
    if( image.source.constructor == Float32Array )
    {
        return {
            width: image.width,
            height: image.height,
            data: image.source
        };
    }

    glsl.gl.pixelStorei(glsl.gl.UNPACK_FLIP_Y_WEBGL, true);

    // https://stackoverflow.com/questions/4702032/accessing-image-texture-data-texels-on-webgl
    // Create a framebuffer backed by the texture
    let framebuffer = glsl.gl.createFramebuffer();
    glsl.gl.bindFramebuffer(glsl.gl.FRAMEBUFFER, framebuffer);
    glsl.gl.framebufferTexture2D(glsl.gl.FRAMEBUFFER, glsl.gl.COLOR_ATTACHMENT0, glsl.gl.TEXTURE_2D, image.texture, 0);

    // Read the contents of the framebuffer (data stores the pixel data)
    let dataU8 = new Uint8Array(image.width * image.height * 4);
    glsl.gl.readPixels(0, 0, image.width, image.height, glsl.gl.RGBA, glsl.gl.UNSIGNED_BYTE, dataU8);

    glsl.gl.deleteFramebuffer(framebuffer);

    let dataF32 = new Float32Array(image.width * image.height * 4);
    
    // flip vertially and u8 to f32
    for(let y = 0 ; y < image.height ; ++y)
    {
        let y_dst = y;
        let y_src = image.height - 1 - y;
        for(let x = 0 ; x < image.width ; ++x)
        {
            let src_index = (y_src * image.width + x) * 4;
            let dst_index = (y_dst * image.width + x) * 4;
            for(let i = 0 ; i < 4 ; ++i)
            {
                dataF32[src_index + i] = dataU8[dst_index + i] / 255.0;
            }
        }
    }
    return {
        width: image.width,
        height: image.height,
        data: dataF32
    };
}
function onTriggeredUpdateImage()
{
    // console.log("onTriggeredUpdateImage");
    glsl.textures["u_image_L"].loading.then( image => {
        imageLRaw = downloadTextureAsFloat(image);
        console.log(imageLRaw);
    });
    glsl.textures["u_image_R"].loading.then( image => {
        imageRRaw = downloadTextureAsFloat(image);
        console.log(imageRRaw);
    });

    // console.log("onUpdatedTextures");
    // const imageL = glsl.textures["u_image_L"];
    // const imageR = glsl.textures["u_image_R"];
    // console.log(`imageL ${imageL.width} x ${imageL.height}` );
    // console.log(`imageR ${imageR.width} x ${imageR.height}` );

    // imageL.loading.then( image => {
    //     console.log("then!!");
    // });
    // imageR.loading.then( texture => {
    //     console.log("then!!");
    // });
    
    // const imageDataL = downloadTextureAsFloat(imageL);
    // const imageDataR = downloadTextureAsFloat(imageR);
    // console.log(imageDataL);
    // console.log(imageDataR);
}

// Run once for initialize
onTriggeredUpdateImage();

function randomScalingFactor() {
    return Math.round(Math.random() * 200 - 100);
};
    
// https://api.jqueryui.com/dialog/#event-resize
function doUpdateSLCanvas( event, ui )
{
    const slcanvas = document.getElementById('slcanvas');
    const context = uicanvas.getContext('2d');
    const sldialog = $("#sldialog");
    let canvasParent = document.getElementById("sldialog");
    // let w = Math.round(sldialog.width());
    // let h = Math.round(sldialog.height());
    
    // sldialog.width(w);
    // sldialog.height(h);
    slcanvas.width = Math.round(canvasParent.clientWidth);
    slcanvas.height = Math.round(canvasParent.clientHeight);
}

const slcanvas = document.getElementById('slcanvas');
const slcontext = slcanvas.getContext('2d');
function drawCanvas()
{
    slcontext.fillRect(0, 0, slcontext.width, slcontext.height);
    slcontext.beginPath();
    slcontext.moveTo(120, 60);
    slcontext.lineTo(240, 90);
    slcontext.stroke();
}
function onSliceGraph()
{
    $( "#sldialog" ).dialog({
        width: 400,
        height: 200,
       open: function (event) {
        //https://stackoverflow.com/questions/1619750/how-can-you-disable-scroll-bars-in-the-jquery-ui-dialog-box
        $('#sldialog').css('overflow', 'hidden'); //Hide Scroll Bar
        doUpdateSLCanvas();
        //drawCanvas();
       },
       close: function (event) {
           console.log("close");
       },
       resize: function( event, ui ) {
        //ui.size.width = Math.round(ui.size.width);
        //ui.size.width = Math.round(ui.size.width);

        // slchart.canvas.parentNode.style.height = slcanvas.width + 'px';
        // slchart.canvas.parentNode.style.width = slcanvas.height + 'px';
           
        doUpdateSLCanvas();
        //drawCanvas();
       },
    });
}

</script>
</body>
</html>
