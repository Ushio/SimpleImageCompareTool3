<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
    <title>SimpleImageCompareTool3</title>

    <script src="jquery-3.3.1.min.js"></script>
    <script src="jquery.event.move.js"></script>
    <script src="jquery.knob.js"></script>

    <link rel="stylesheet" href="jquery-ui.min.css">
    <script src="jquery-ui.min.js"></script>

    <script src="GlslCanvas.js"></script>
    <script src="FileSaver.js"></script>
    <script src="paste.js"></script>
    <script src="exrapi_compiled.js"></script>
    
    <link rel="stylesheet" href="huebee.css">
    <script src="huebee.pkgd.js"></script>

    <link rel="stylesheet" href="check.css">
    <link rel="stylesheet" href="slider.css">
    <link rel="stylesheet" href="combo.css">

    <script src="uPlot.iife.js"></script>
    <link rel="stylesheet" href="uPlot.min.css">

    <script src="UPNG.js"></script>
    <script src="pako.min.js"></script>
    <script src="jquery.blockUI.js"></script>
    <style>
        .dragover {
            background:rgb(193, 225, 255);
        }
        .boxspan {
            display: inline-block;
            width: 100%;
            text-align: center;
            line-height:50px;
        }

        /* disable pixel filter */
        .disablePixelFilter {
            image-rendering: optimizeSpeed;             /* Older versions of FF          */
            image-rendering: -moz-crisp-edges;          /* FF 6.0+                       */
            image-rendering: -webkit-optimize-contrast; /* Safari                        */
            image-rendering: -o-crisp-edges;            /* OS X & Windows Opera (12.02+) */
            image-rendering: pixelated;                 /* Awesome future-browsers       */
            -ms-interpolation-mode: nearest-neighbor;   /* IE                            */
        }

        .ui-dialog-titlebar{
            padding: 0.3rem !important;
            font-size: 0.75rem;
        }
    </style>
</head>

<body>
<div style="margin: 10px;">
    <div style="width: 100%; display: flex; ">
        <div id="drop-zoneL" style="height: 50px; width: 100%; border: thin solid #acacac;  border-radius: 10px;"><span class="boxspan">Left Image (Please drop your image here)</span></div>
        <div style="width: 20px;"></div>
        <div id="drop-zoneR" style="height: 50px; width: 100%; border: thin solid #acacac;  border-radius: 10px;"><span class="boxspan">Right Image (Please drop your image here)</span></div>
    </div>
</div>

<div id="layerview" style="display:none;">
<div style="margin-left: 30px; margin-right: 30px; display: flex; justify-content: space-between;" >
    <select id="layerL" name="layerL" style="font-size: 18px;">
        <option value="">RGB</option>
    </select>
    <select id="layerR" name="layerR" style="font-size: 18px;">
        <option value="">RGB</option>
    </select>
</div>
</div>

<div style="height: 8px"></div> <!--  margin -->

<div style="display: flex; justify-content: center; align-items: baseline;" id="glcontainer">
    <canvas id="glcanvas" style="max-width:100%; height:auto;" class="disablePixelFilter">
</div>

<div style="display: flex; justify-content: center; align-items: baseline; position: absolute; left: 0px; top: 0px; z-index: 10;" id="uicontainer">
    <canvas id="uicanvas" style="max-width:100%; height:auto;">
</div>

<style>
.ui_container > div {
    flex-basis: 160px;
    height: 160px;
    margin: 5px;
    padding: 12px;
    background: #ffffff;
    border-radius: 10px;
    box-shadow:0px 1px 0px 1px #d5d5d5;
}
</style>
<div style="margin:20px; padding:10px; background: #ececec; border-radius: 10px;">
    <div style="display: flex; flex-wrap: wrap; " class="ui_container">
        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Direction</div>
            <div id="dial_container">
                <input type="text" value="0" class="direction_dial" data-width="100" data-displayInput=false data-thickness=.5 data-cursor=true>
            </div>
            <select id="fixed_direction" name="fixed_direction">
                <option value="">Free Direction</option>
                <option value="↘">↘</option>
                <option value="↗">↗</option>
                <option value="↖">↖</option>
                <option value="↙">↙</option>
            </select>
        </div>
        
        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Border</div>
            <div style="height: 4px"></div> <!--  margin -->
            <div style="text-align: center;" id="borderlabel">2 px</div>
            <div style="height: 10px"></div> <!--  margin -->
            <input type="range" value="2" min="0" max="32" step="1" id="border" class="slider">
            <div style="height: 20px"></div> <!--  margin -->
            <div style="text-align: center;">color</div>
            <div style="height: 6px"></div> <!--  margin -->
            <input class="border_color" value="#000000" style="width:130px"/>
        </div>

        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Labels</div>
            <div style="height: 25px"></div> <!--  margin -->
            <input value="" style="width:130px" id="Label_L_override"/>
            <div style="height: 10px"></div> <!--  margin -->
            <input value="" style="width:130px" id="Label_R_override"/>
        </div>

        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Font</div>
            <div style="height: 4px"></div> <!--  margin -->
            <div style="text-align: center;" id="fontsizelabel">20 px</div>
            <div style="height: 10px"></div> <!--  margin -->
            <input type="range" value="20" min="0" max="100" step="1" id="fontsize" class="slider">
            <div style="height: 20px"></div> <!--  margin -->
            <div style="text-align: center;">color</div>
            <div style="height: 6px"></div> <!--  margin -->
            <input class="font_color" value="#FF0000" style="width:130px"/>
        </div>

        <div style="display: flex; flex-direction:column; align-items: center;" id="fperror">
            <div style="text-align: center;">Floating Point Error</div>
            <div style="height: 5px"></div> <!--  margin -->
            <div style="text-align: center; font-size: 14px;">NaN</div>
            <input class="Nan_Color" value="#FF0000" style="width:130px"/>
            <div style="height: 5px"></div> <!--  margin -->
            <div style="text-align: center; font-size: 14px;">Infinity</div>
            <div style="height: 5px"></div> <!--  margin -->
            <input class="Inf_Color" value="#FF00FF" style="width:130px"/>
            <div style="text-align: center; font-size: 11px;" id="L_fpLabel"></div>
            <div style="text-align: center; font-size: 11px;" id="R_fpLabel"></div>
        </div>

        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Diff Mode</div>
            <div style="height: 20px"></div> <!--  margin -->
            <div class="onoffswitch">
                <input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="diffmode" onchange="didChangeDiffMode(this.checked)">
                <label class="onoffswitch-label" for="diffmode"></label>
            </div>
            <div style="height: 20px"></div> <!--  margin -->
            <div style="text-align: center; opacity:0.3;" id="diffscalelabel">100 %</div>
            <input type="range" value="100" min="100" max="500" step="1" id="diffscale" style="opacity:0.3;" class="slider">
        </div>

        <style>
            .PasteAreaL:focus-within {
                background:rgb(91, 88, 255);
            }
            .PasteAreaR:focus-within {
                background:rgb(91, 88, 255);
            }
        </style>
        <div style="display: flex; flex-direction:column; align-items: center; ">
            <div style="text-align: center;">Click and Paste L↓</div>
            <div class="PasteAreaL" style="height: 80%; width: 90%; border: thin solid #acacac;"></div>
        </div>
        <div style="display: flex; flex-direction:column; align-items: center; ">
            <div style="text-align: center;">Click and Paste R↓</div>
            <div class="PasteAreaR" style="height: 80%; width: 90%; border: thin solid #acacac;"></div>
        </div>
        
        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Loupe</div>
            <div style="height: 10px"></div> <!--  margin -->
            <div class="onoffswitch">
                <input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="loupeMode" onchange="didChangeLoupeMode(this.checked)">
                <label class="onoffswitch-label" for="loupeMode"></label>
            </div>
            <div style="height: 10px"></div> <!--  margin -->
            <div style="text-align: center; opacity:0.3;" id="loupeSizeLabel">150 px</div>
            <div style="height: 5px"></div> <!--  margin -->
            <input type="range" value="150" min="10" max="500" step="10" id="loupeSize" style="opacity:0.3;" class="slider">
            <div style="height: 10px"></div> <!--  margin -->
            <div style="text-align: center; opacity:0.3;" id="loupeScaleLabel">200 %</div>
            <div style="height: 5px"></div> <!--  margin -->
            <input type="range" value="200" min="100" max="500" step="10" id="loupeScale" style="opacity:0.3;" class="slider">
        </div>

        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Post Process</div>
            <div style="height: 10px"></div> <!--  margin -->
            <div class="onoffswitch">
                <input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="PostProcess" onchange="didChangePostProcess(this.checked)">
                <label class="onoffswitch-label" for="PostProcess"></label>
            </div>
            <div style="height: 10px"></div> <!--  margin -->
            <div style="text-align: center; opacity:0.3;" id="postScaleLabel">100 %</div>
            <div style="height: 10px"></div> <!--  margin -->
            <input type="range" value="100" min="10" max="300" step="10" id="postScale" style="opacity:0.3;" class="slider">
            <div style="height: 22px"></div> <!--  margin -->
            <select id="GammaSelect" style="opacity:0.3;">
                <option value="1.0">Gamma 1.0</option>
                <option value="2.2" selected>Gamma 2.2</option>
                <option value="2.4">Gamma 2.4</option>
                <option value="1.0">ACEScg to sRGB</option>
            </select>
        </div>

        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Slice Graph</div>
            <div style="height: 10px"></div> <!--  margin -->
            <button style="
                background: url('icSliceGraph.svg') no-repeat center;
                height: 100px;
                width: 100px;
                border: 2px solid #E8E8E8;
            " onclick="onSliceGraph()" id="slicebutton"></button>
        </div>

        <div style="display: flex; flex-direction:column; align-items: center; margin-left: auto;">
            <div style="text-align: center;">Record</div>
            <div style="height: 10px"></div> <!--  margin -->
            <button style="
                background: url('Rec.svg') no-repeat center;
                height: 100px;
                width: 100px;
                color: white;
            " id="REC" onclick="onSaveAnimation()"></button>
        </div>
        <div style="display: flex; flex-direction:column; align-items: center;">
            <div style="text-align: center;">Save</div>
            <div style="height: 10px"></div> <!--  margin -->
            <button style="
                background: url('save.svg') no-repeat center;
                height: 100px;
                width: 100px;
                color: white;
            " onclick="onSave()"></button>
        </div>
    </div>
</div>

<a href="https://github.com/Ushio/SimpleImageCompareTool3">Github Repo</a>

<div hidden>
    <div id="sldialog" title="Slice Graph" style="padding: 0;margin:0">
        <!-- <div style="
        background-color: rgb(255, 0, 200);
        top: 0;
        left: 0;
        width: 100%;
        height: 50px;
        ">
        <canvas id="slcanvas" style="
            background-color: aqua;
            /* position: absolute; */
            top: 0;
            left: 0;
            /* width: 100%;
            height: 100%; */
        "> </canvas>
        </div> -->
    </div>
</div>

<script>
'use strict';

// Vector
function add(a, b)
{
    return {
        x: a.x + b.x,
        y: a.y + b.y,
    };
}
function sub(a, b)
{
    return {
        x: a.x - b.x,
        y: a.y - b.y,
    };
}
function mulScalar(a, s)
{
    return {
        x: a.x * s,
        y: a.y * s,
    };
}
function dot(a, b)
{
    return a.x * b.x + a.y * b.y;
}
function lerp(a, b, amt)
{
    return a + (b - a) * amt;
}

const canvas = document.getElementById('glcanvas');
const glsl = new GlslCanvas(canvas, {preserveDrawingBuffer: true});

const uicanvas = document.getElementById('uicanvas');
const uictx = uicanvas.getContext('2d');
const compositecanvas = document.createElement('canvas');

function invokeRender() {
    glsl.forceRender = true;
    glsl.render();
    glsl.forceRender = false;
}

let L_filename = "L";
let R_filename = "R";

let angle = 0.0; // for label location

// be careful. this should point initial image size
canvas.width = 1200;
canvas.height = 722;

const HILIGHT_VALUE = 0.4;

// for exr
let imageLayeredL = null;
let imageLayeredR = null;

// for Slice Graph. left to right and top to bottom order.
let imageLRaw = null;
let imageRRaw = null;

// relative to ui canvas. up positive.
let sliceVertices = [
    { x: 0.25, y: 0.5 },
    { x: 0.75, y: 0.5 },
];
const SLICE_VERTEX_RADIUS = 18;
const SLICE_MODE_NONE = 0;
const SLICE_MODE_DRAG = 1;
const SLICE_MODE_NEW  = 2;
const SLICE_MODE_DRAG_LINE  = 3;

let sliceVertexGrab = -1;
let isSliceGraphShowing = false;
let sliceMode = SLICE_MODE_NONE;

let grabbaseVertices = [
    { x: 0.25, y: 0.5 },
    { x: 0.75, y: 0.5 },
];
let grabbaseX = 0;
let grabbaseY = 0;

let focusSliceAMT = null;

// for flexible drop
let glu_directionX = 1;
let glu_directionY = 0;
let glu_direction_fixedX = 0;
let glu_direction_fixedY = 0;
let glu_mouselocationX = canvas.width * 0.5;
let glu_mouselocationY = canvas.height * 0.5;
let mouseLocationXLocalAlways = 0;
let mouseLocationYLocalAlways = 0;

function setCanvasSize( w, h )
{
    if( canvas.width === w && canvas.height === h )
    {
        return;
    }

    let nx = glu_mouselocationX / canvas.width;
    let ny = glu_mouselocationY / canvas.height;
    canvas.width = w;
    canvas.height = h;
    glu_mouselocationX = nx * canvas.width;
    glu_mouselocationY = ny * canvas.height;
    glsl.setUniform("u_mouselocation", glu_mouselocationX , glu_mouselocationY);
}

function getImageLabelL() 
{
    return $("#Label_L_override")[0].value || L_filename;
}
function getImageLabelR() 
{
    return $("#Label_R_override")[0].value || R_filename;
}

glsl.on("render", function(e) {
    const glcontainer = $('#glcontainer');
    var offset = glcontainer.offset();

    $('#uicontainer')
        .css('left', offset.left)
        .css('top', offset.top)
        .width (glcontainer.width())
        .height(glcontainer.height());

    uicanvas.width  = canvas.width;
    uicanvas.height = canvas.height;
    
    const fontsize = $("#fontsize")[0].value;
    const font_color = $(".font_color")[0].value;
    const TEXT_MARGIN = 15;

    const Location = {
        LT : 1,
        RT : 2,
        LB : 3,
        RB : 4
    };
    function drawText(text, location) {
        if(fontsize == "0") {
            return;
        }
        uictx.save();
        uictx.font = fontsize + "px Arial";
        uictx.fillStyle = font_color;
        uictx.strokeStyle = "white";

        uictx.lineWidth = parseFloat(fontsize) / 6.0;
        uictx.lineJoin = "round";
        
        let x, y;
        if(location == Location.LT || location == Location.RT){
            uictx.textBaseline = "top";
            y = TEXT_MARGIN;
        } else {
            uictx.textBaseline = "bottom";
            y = uicanvas.height - TEXT_MARGIN;
        }
        if(location == Location.LT || location == Location.LB){
            uictx.textAlign = "left";
            x = TEXT_MARGIN;
        } else {
            uictx.textAlign = "right";
            x = uicanvas.width - TEXT_MARGIN;
        }
        
        uictx.strokeText(text, x, y);
        uictx.fillText(text, x, y);
        uictx.restore();
    }

    let label_L = getImageLabelL();
    let label_R = getImageLabelR();

    const fixed_direction = $('[name="fixed_direction"] option:selected').val();
    if(fixed_direction) {
        // fixed label
        if(fixed_direction === "↘") {
            drawText(label_L, Location.LT);
            drawText(label_R, Location.RB);
        }
        if(fixed_direction === "↗") {
            drawText(label_L, Location.LB);
            drawText(label_R, Location.RT);
        }
        if(fixed_direction === "↖") {
            drawText(label_L, Location.RB);
            drawText(label_R, Location.LT);
        }
        if(fixed_direction === "↙") {
            drawText(label_L, Location.RT);
            drawText(label_R, Location.LB);
        }
    } else {
        // automatic
        if(angle < -135.0) {
            drawText(label_L, Location.RT);
            drawText(label_R, Location.LT);
        }
        else if(-135.0 <= angle && angle < -95.0) {
            drawText(label_L, Location.RT);
            drawText(label_R, Location.LB);
        }
        else if(-95.0 <= angle && angle < -85.0) {
            drawText(label_L, Location.LT);
            drawText(label_R, Location.LB);
        }
        else if(-85.0 <= angle && angle < -45.0) {
            drawText(label_L, Location.LT);
            drawText(label_R, Location.RB);
        }
        else if(-45.0 <= angle && angle < 45.0) {
            drawText(label_L, Location.LT);
            drawText(label_R, Location.RT);
        } else if(45.0 <= angle && angle < 85.0) {
            drawText(label_L, Location.LB);
            drawText(label_R, Location.RT);
        } else if(85.0 <= angle && angle < 95.0) {
            drawText(label_L, Location.LB);
            drawText(label_R, Location.LT);
        } else if(95.0 <= angle && angle < 135.0) {
            drawText(label_L, Location.RB);
            drawText(label_R, Location.LT);
        }
        else if(135.0 <= angle && angle <= 180.0) {
            drawText(label_L, Location.RT);
            drawText(label_R, Location.LT);
        }
    }

    if( isSliceGraphShowing )
    {
        let bodyInteractable = sliceMode !== SLICE_MODE_NONE || distanceLinePoint(
                sliceVertices[0].x * uicanvas.width, sliceVertices[0].y * uicanvas.height, 
                sliceVertices[1].x * uicanvas.width, sliceVertices[1].y * uicanvas.height,
                mouseLocationXLocalAlways,
                mouseLocationYLocalAlways
        ) < SLICE_VERTEX_RADIUS;

        let begInteractable = distancePointPoint(mouseLocationXLocalAlways, mouseLocationYLocalAlways, sliceVertices[0].x * uicanvas.width, sliceVertices[0].y * uicanvas.height) < SLICE_VERTEX_RADIUS;
        let endInteractable = distancePointPoint(mouseLocationXLocalAlways, mouseLocationYLocalAlways, sliceVertices[1].x * uicanvas.width, sliceVertices[1].y * uicanvas.height) < SLICE_VERTEX_RADIUS;
        if(begInteractable || endInteractable)
        {
            bodyInteractable = false;
        }
        if(bodyInteractable)
        {
            begInteractable = true;
            endInteractable = true;
        }

        // flip y and relative to absolute
        let p0x = sliceVertices[0].x * uicanvas.width;
        let p0y = uicanvas.height - 1 - sliceVertices[0].y * uicanvas.height;
        let p1x = sliceVertices[1].x * uicanvas.width;
        let p1y = uicanvas.height - 1 - sliceVertices[1].y * uicanvas.height;

        // arrow
        let dx = p1x - p0x;
        let dy = p1y - p0y;
        let dLength = Math.sqrt(dx * dx + dy * dy);
        dx /= dLength;
        dy /= dLength;
        let theta = 30.0 * Math.PI / 180.0;
        let arrowTheta0 = Math.PI - theta;
        let arrowTheta1 = Math.PI + theta;
        let dxArrow0 = Math.cos(arrowTheta0) * dx - Math.sin(arrowTheta0) * dy;
        let dyArrow0 = Math.sin(arrowTheta0) * dx + Math.cos(arrowTheta0) * dy;
        let dxArrow1 = Math.cos(arrowTheta1) * dx - Math.sin(arrowTheta1) * dy;
        let dyArrow1 = Math.sin(arrowTheta1) * dx + Math.cos(arrowTheta1) * dy;
    
        // Origin base
        uictx.lineCap = "round";
        uictx.beginPath();
        uictx.arc(p0x, p0y, SLICE_VERTEX_RADIUS * 0.5 /* R */, 0, 2 * Math.PI, false);
        uictx.lineWidth = begInteractable ? 8 : 6;
        uictx.strokeStyle = begInteractable ? 'rgba(255, 255, 255, 1)' : 'rgba(255, 255, 255, 0.8)';
        uictx.stroke();

        function arrowBody(ctx)
        {
            ctx.moveTo(p0x, p0y);
            ctx.lineTo(p1x, p1y);
        };
        function arrowHead(ctx)
        {
            ctx.moveTo(p1x, p1y);
            ctx.lineTo(p1x + dxArrow0 * SLICE_VERTEX_RADIUS * 0.8, p1y + dyArrow0 * SLICE_VERTEX_RADIUS * 0.8);
            ctx.moveTo(p1x, p1y);
            ctx.lineTo(p1x + dxArrow1 * SLICE_VERTEX_RADIUS * 0.8, p1y + dyArrow1 * SLICE_VERTEX_RADIUS * 0.8);
        };
        
        // Body base
        uictx.beginPath();
        arrowBody(uictx);
        uictx.lineWidth = bodyInteractable ? 6 : 4;
        uictx.strokeStyle = bodyInteractable ? 'rgba(255, 255, 255, 1)' : 'rgba(255, 255, 255, 0.8)';
        uictx.stroke();

        // Head base
        uictx.beginPath();
        arrowHead(uictx);
        uictx.lineWidth = endInteractable ? 6 : 4;
        uictx.strokeStyle = endInteractable ? 'rgba(255, 255, 255, 1)' : 'rgba(255, 255, 255, 0.8)';
        uictx.stroke();

        // Origin
        uictx.beginPath();
        uictx.arc(p0x, p0y, SLICE_VERTEX_RADIUS * 0.5 /* R */, 0, 2 * Math.PI, false);
        uictx.lineWidth = 1.5;
        uictx.strokeStyle = begInteractable ? 'rgba(255, 0, 0, 1)' : 'rgba(230, 0, 0, 0.8)';
        uictx.stroke();

        // Body
        uictx.beginPath();
        arrowBody(uictx);
        uictx.lineWidth = 1.5;
        uictx.strokeStyle = bodyInteractable ? 'rgba(255, 0, 0, 1)' : 'rgba(230, 0, 0, 0.8)';
        uictx.setLineDash([16, 8]);
        uictx.stroke();

        // Head
        uictx.beginPath();
        arrowHead(uictx);
        uictx.lineWidth = 1.5;
        uictx.strokeStyle = endInteractable ? 'rgba(255, 0, 0, 1)' : 'rgba(230, 0, 0, 0.8)';
        uictx.setLineDash([16, 8]);
        uictx.stroke();

        if(focusSliceAMT !== null)
        {
            let fx = lerp(p0x, p1x, focusSliceAMT);
            let fy = lerp(p0y, p1y, focusSliceAMT);

            uictx.beginPath();
            uictx.moveTo(fx - SLICE_VERTEX_RADIUS * 0.6, fy - SLICE_VERTEX_RADIUS * 0.6);
            uictx.lineTo(fx + SLICE_VERTEX_RADIUS * 0.6, fy + SLICE_VERTEX_RADIUS * 0.6);
            uictx.moveTo(fx - SLICE_VERTEX_RADIUS * 0.6, fy + SLICE_VERTEX_RADIUS * 0.6);
            uictx.lineTo(fx + SLICE_VERTEX_RADIUS * 0.6, fy - SLICE_VERTEX_RADIUS * 0.6);
            uictx.lineWidth = 5;
            uictx.strokeStyle = 'rgba(255, 255, 255, 1)';
            uictx.setLineDash([]);
            uictx.stroke();

            uictx.beginPath();
            uictx.moveTo(fx - SLICE_VERTEX_RADIUS * 0.6, fy - SLICE_VERTEX_RADIUS * 0.6);
            uictx.lineTo(fx + SLICE_VERTEX_RADIUS * 0.6, fy + SLICE_VERTEX_RADIUS * 0.6);
            uictx.moveTo(fx - SLICE_VERTEX_RADIUS * 0.6, fy + SLICE_VERTEX_RADIUS * 0.6);
            uictx.lineTo(fx + SLICE_VERTEX_RADIUS * 0.6, fy - SLICE_VERTEX_RADIUS * 0.6);
            uictx.lineWidth = 2;
            uictx.strokeStyle = 'rgba(255, 0, 255, 1)';
            uictx.setLineDash([]);
            uictx.stroke();
        }
    }
});

// UI Drawing
// setInterval(function () {
// }, 
// 100);

$(window).resize(invokeRender);

// we don't need auto rendering loop
glsl.pause();

// Load only the Fragment Shader
var fs = `
#extension GL_OES_standard_derivatives : enable
#ifdef GL_ES
precision mediump float;
#endif
    uniform vec2  u_resolution;
    uniform vec2  u_mouselocation;
    uniform vec2  u_direction;
    uniform vec2  u_direction_fixed;
    uniform float u_border;
    uniform vec3  u_border_color;
    uniform float u_diffmode;
    uniform float u_diffscale;

    uniform float u_loupemode;
    uniform float u_loupeSize;
    uniform float u_loupeScale;

    uniform float u_postProcess;
    uniform float u_postScale;
    uniform float u_postGamma;
    uniform float u_ACEScgToSRGB;

    uniform float u_hilightL;
    uniform float u_hilightR;

    uniform sampler2D u_image_L;
    uniform sampler2D u_image_R;

    uniform vec3 u_Nan_Color;
    uniform vec3 u_Inf_Color;
    
    float border(vec2 fragcood, vec2 n, vec2 p) {
        float base = dot(p,        n);
        float x    = dot(fragcood, n);
        return x - base;
    }

    float sRGBGamma( float u )
    {
        if( u < 0.0031308 )
        {
            return 12.92 * u;
        }
        return 1.055 * pow(u, 1.0 / 2.4) - 0.055;
    }
    vec4 applyPost(vec4 c)
    {
        if( u_postProcess != 0.0 )
        {
            if( u_ACEScgToSRGB != 0.0 )
            {
                // https://www.colour-science.org/apps/
                // ACEScg to sRGB
                // Chromatic Adaption Transform: Bianco
                c *= u_postScale;
                float r = c.x * 1.7070626733 + c.y * -0.6199595404 + c.z * -0.0872598502;
                float g = c.x * -0.1309768295 + c.y * 1.1390322752 + c.z * -0.0079562968;
                float b = c.x * -0.0245106012 + c.y * -0.1248109317 + c.z * 1.1493959705;
                c = vec4(
                    sRGBGamma( r ), 
                    sRGBGamma( g ), 
                    sRGBGamma( b ), 
                    1.0);
            }
            else
            {
                c.x = pow(u_postScale * c.x, 1.0 / u_postGamma);
                c.y = pow(u_postScale * c.y, 1.0 / u_postGamma);
                c.z = pow(u_postScale * c.z, 1.0 / u_postGamma);
            }
        }
        return c;
    }

    // https://stackoverflow.com/questions/11810158/how-to-deal-with-nan-or-inf-in-opengl-es-2-0-shaders
    bool isnan( float val )
    {
        return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true;
    }
    #define FLT_MAX 3.402823466e+38
    bool isinf(float n) 
    {
        return FLT_MAX < abs(n);
    }
    vec4 GetImageL(vec2 st)
    {
        vec4 c = texture2D(u_image_L, st);

        if(isnan(c.x) || isnan(c.y) || isnan(c.z) || isnan(c.w)) {
            c = vec4(u_Nan_Color, 1.0);
        } else if( isinf(c.x) || isinf(c.y) || isinf(c.z) || isinf(c.w) ) {
            c = vec4(u_Inf_Color, 1.0);
        }
        return clamp(c, vec4(0.0), vec4(1024.0));
    }
    vec4 GetImageR(vec2 st)
    {
        vec4 c = texture2D(u_image_R, st);
        if(isnan(c.x) || isnan(c.y) || isnan(c.z) || isnan(c.w)) {
            c = vec4(u_Nan_Color, 1.0);
        } else if( isinf(c.x) || isinf(c.y) || isinf(c.z) || isinf(c.w) ) {
            c = vec4(u_Inf_Color, 1.0);
        }
        return clamp(c, vec4(0.0), vec4(1024.0));
    }
    vec4 addHilightL(vec4 c)
    {
        return mix(c, vec4(1.0), u_hilightL);
    }
    vec4 addHilightR(vec4 c)
    {
        return mix(c, vec4(1.0), u_hilightR);
    }

    void main() {
        vec2 fragcoord = gl_FragCoord.xy;
        vec2 st = fragcoord / u_resolution.xy;

        vec4 L = GetImageL(st);
        vec4 R = GetImageR(st);

        if(0.0 < u_diffmode) {
            L = abs(L - R) * u_diffscale;
        }

        L = addHilightL(L);
        R = addHilightR(R);

        if(0.1 < mod(u_border, 2.0)) {
            fragcoord += vec2(0.5);
        }

        // 
        vec2 direction = 0.0 < length(u_direction_fixed) ? u_direction_fixed : u_direction;
        
        float b = border(fragcoord, direction, u_mouselocation);

        bool is_straight = abs(direction.x) < 1.0e-5 || abs(direction.y) < 1.0e-5;
        float delta = is_straight ? 0.0 : 0.9 /* feeling constant */;

        float s = smoothstep(-delta, delta, b);

        gl_FragColor = mix(L, R, s);
        
        // Loupe
        float loupedelta = 0.9; 
        if(0.0 < u_loupemode)
        {
            float size = u_loupeSize;
            float scale = u_loupeScale;
            
            // center of loupe
            vec2 lhs = u_mouselocation - direction * size * 0.6 /*bias*/;
            {
                float alpha = 1.0 - smoothstep( size * 0.5 - loupedelta, size * 0.5 + loupedelta, distance(fragcoord, lhs) );
                vec2 localcoord = fragcoord - lhs;
                vec2 sample = (localcoord / scale + u_mouselocation)  / u_resolution.xy;
                gl_FragColor.rgb = mix(gl_FragColor.rgb, GetImageL(sample).rgb, alpha);
            }

            // center of loupe
            vec2 rhs = u_mouselocation + direction * size * 0.6 /*bias*/;
            {
                float alpha = 1.0 - smoothstep( size * 0.5 - loupedelta, size * 0.5 + loupedelta, distance(fragcoord, rhs) );
                vec2 localcoord = fragcoord - rhs;
                vec2 sample = (localcoord / scale + u_mouselocation)  / u_resolution.xy;
                gl_FragColor.rgb = mix(gl_FragColor.rgb, GetImageR(sample).rgb, alpha);
            }

            gl_FragColor = applyPost(gl_FragColor);

            if( 0.0 < u_border ) {
                float a = smoothstep(u_border * 0.5 - loupedelta, u_border * 0.5 + loupedelta, abs(distance(fragcoord, lhs) - size * 0.5));
                float b = smoothstep(u_border * 0.5 - loupedelta, u_border * 0.5 + loupedelta, abs(distance(fragcoord, rhs) - size * 0.5));
                gl_FragColor.rgb = mix(u_border_color, gl_FragColor.rgb, a * b);
            }
        }
        else
        {
            gl_FragColor = applyPost(gl_FragColor);
        }

        if(0.0 < u_border) {
            float bar = u_border * 0.5;
            float bar_window = smoothstep(bar - delta, bar + delta, abs(b));
            gl_FragColor.rgb = mix(u_border_color, gl_FragColor.rgb, bar_window);
        }
        
        gl_FragColor.a = 1.0;
    }
`;
glsl.load(fs);

L_filename = "dogs-before";
R_filename = "dogs-after";
$('#Label_L_override').attr("placeholder", L_filename);
$('#Label_R_override').attr("placeholder", R_filename);

// Default Values
glsl.setUniform("u_image_L", "dogs-before.jpg");
glsl.setUniform("u_image_R", "dogs-after.jpg");
glsl.setUniform("u_direction", 1.0, 0.0);
glsl.setUniform("u_mouselocation", canvas.width * 0.5, canvas.height * 0.5);
glsl.setUniform("u_border", 2);
glsl.setUniform("u_border_color", 0.0, 0.0, 0.0);
glsl.setUniform("u_diffmode", 0.0);
glsl.setUniform("u_diffscale", 1.0);
glsl.setUniform("u_direction_fixed", 0.0, 0.0);
glsl.setUniform("u_loupeMode", 0.0);
glsl.setUniform("u_loupeSize", 150.0);
glsl.setUniform("u_loupeScale", 2.0);
glsl.setUniform("u_postProcess", 0.0);
glsl.setUniform("u_postScale", 1.0);
glsl.setUniform("u_postGamma", 2.2);
glsl.setUniform("u_ACEScgToSRGB", 0.0);
glsl.setUniform("u_hilightL", 0.0);
glsl.setUniform("u_hilightR", 0.0);
glsl.setUniform("u_Nan_Color", 1.0, 0.0, 0.0);
glsl.setUniform("u_Inf_Color", 1.0, 0.0, 1.0);

// Mouse Move & Mouse Up is need global event  -> html
// Mouse Down shouldn't work outside of canvas -> EVENT_VIEW
const EVENT_VIEW = "#uicanvas";

var down = false;

let isRecording = false;
let recMove = 0.0;
let recFrames = [];
let recDates = [];

// mouseLocationXLocalAlways, mouseLocationYLocalAlways are always updated.
// glu_mouselocationX, glu_mouselocationY and glsl.setUniform are updated just when down == true
function updateMouseLocation(e) {
    {
        // Coordinate transform
        // https://qiita.com/yukiB/items/cc533fbbf3bb8372a924#2-jquery%E3%81%AEoffset%E3%81%A8eventpagexy%E3%82%92%E4%BD%BF%E7%94%A8
        const offset = $('#glcanvas').offset();
        const x = e.pageX - offset.left;
        const y = e.pageY - offset.top;
        e.offsetX = x;
        e.offsetY = y;
    }
    const scale = canvas.width / canvas.clientWidth;
    const x = e.offsetX * scale;
    const y = canvas.height - e.offsetY * scale;
    if(down) {
        // recording process 
        if( isRecording )
        {
            let dx = glu_mouselocationX - x;
            let dy = glu_mouselocationY - y;
            recMove += Math.sqrt(dx * dx + dy * dy);
            if( 16 < recMove )
            {
                recMove = 0.0;

                glsl.setUniform("u_mouselocation", Math.round(x), Math.round(y));
                invokeRender();
    
                compositecanvas.width = canvas.width;
                compositecanvas.height = canvas.height;
                const compositecanvasCtx = compositecanvas.getContext('2d');
                compositecanvasCtx.drawImage(canvas, 0, 0);
                compositecanvasCtx.drawImage(uicanvas, 0, 0);
                
                recFrames.push( compositecanvasCtx.getImageData(0,0,canvas.width,canvas.height).data );
                recDates.push( new Date() );
            }
        }

        glu_mouselocationX = x;
        glu_mouselocationY = y;
        glsl.setUniform("u_mouselocation", Math.round(x), Math.round(y));
    }
    mouseLocationXLocalAlways = x;
    mouseLocationYLocalAlways = y;
}

function Clamp(x, lower, upper) {
  return Math.min(Math.max(x, lower), upper);
}

$("html").mousemove(function(e) {
    updateMouseLocation(e);

    if(sliceMode !== SLICE_MODE_NONE)
    {
        let newX = Clamp(mouseLocationXLocalAlways / uicanvas.width, 0, 1);
        let newY = Clamp(mouseLocationYLocalAlways / uicanvas.height, 0, 1);
        if(sliceMode == SLICE_MODE_DRAG)
        {
            sliceVertices[sliceVertexGrab].x = newX;
            sliceVertices[sliceVertexGrab].y = newY;
        }
        else if (sliceMode == SLICE_MODE_NEW)
        {
            sliceVertices[1].x = newX;
            sliceVertices[1].y = newY;
        }
        else if( sliceMode == SLICE_MODE_DRAG_LINE )
        {
            let dx = (mouseLocationXLocalAlways - grabbaseX) / uicanvas.width;
            let dy = (mouseLocationYLocalAlways - grabbaseY) / uicanvas.height;
            for(let i = 0 ; i < 2 ; ++i)
            {
                sliceVertices[i].x = Clamp((grabbaseVertices[i].x + dx), 0, 1);
                sliceVertices[i].y = Clamp((grabbaseVertices[i].y + dy), 0, 1);
            }
        }

        onSliceGraphUpdate();
    }
    if( isSliceGraphShowing )
    {
        invokeRender();
    }
    
    // disable drag selection effects.
    const uidialog = $('.ui-dialog');
    if (0 < uidialog.length && uidialog.is(':hover')) {
        e.preventDefault();
    }
});
function mouseUp()
{
    down = false;
    sliceVertexGrab = -1;
    sliceMode = SLICE_MODE_NONE;

    if( isRecording )
    {
        if( 1 < recFrames.length )
        {
            $.blockUI({ message: 'encoding...' });
            
            setTimeout(() => {
                let dels = [];
                recDates.push(new Date());
                for(let i = 0 ; i < recDates.length - 1 ; ++i)
                {
                    let delta = recDates[i + 1].getTime() - recDates[i].getTime();
                    dels.push( delta );
                }

                let apng = UPNG.encode( recFrames, canvas.width,canvas.height, 0, dels );
                let blob = new Blob([apng], {type: "application/octet-stream"});
                saveAs(blob, "compare.png");
                
                recFrames = [];
                recDates = [];

                $.unblockUI();
            }, 200);
        }

        isRecording = false;
        recMove = 0.0;

        $('#REC').css('background-image', 'url(Rec.svg)');
    }
}
$("html").mouseup(function() {
    mouseUp();
});
$(EVENT_VIEW).mouseup(function(e) {
    mouseUp();
});
$(EVENT_VIEW).mouseleave(function(e){
    updateMouseLocation(e);
});

function distancePointPoint(p0x, p0y, p1x, p1y)
{
    let dx = p0x - p1x;
    let dy = p0y - p1y;
    return Math.sqrt(dx * dx + dy * dy);
}
function distanceLinePoint(p0x, p0y, p1x, p1y, ox, oy)
{
    let p0 = {x:p0x, y:p0y};
    let p1 = {x:p1x, y:p1y};
    let o = {x:ox, y:oy};
    let a = sub(o, p0);
    let b = sub(p1, p0);
    let c = Clamp(dot(a, b) / dot(b, b), 0, 1);
    let onLine = add(p0, mulScalar(b, c));
    let between = sub(onLine, o);
    return Math.sqrt(dot(between, between));
}

$(EVENT_VIEW).mousedown(function(e){
    updateMouseLocation(e);

    if( isSliceGraphShowing )
    {
        sliceVertexGrab = -1;
        for(let i = 0 ; i < sliceVertices.length ; ++i)
        {
            let sliceX = sliceVertices[i].x * uicanvas.width;
            let sliceY = sliceVertices[i].y * uicanvas.height;
            let d = Math.sqrt(Math.pow(sliceX - mouseLocationXLocalAlways, 2) + Math.pow(sliceY - mouseLocationYLocalAlways, 2));
            if(d < SLICE_VERTEX_RADIUS)
            {
                sliceVertexGrab = i;
                break;
            }
        }
        if(0 <= sliceVertexGrab)
        {
            sliceMode = SLICE_MODE_DRAG;
        }
        else
        {
            let d = distanceLinePoint(
                sliceVertices[0].x * uicanvas.width, sliceVertices[0].y * uicanvas.height, 
                sliceVertices[1].x * uicanvas.width, sliceVertices[1].y * uicanvas.height,
                mouseLocationXLocalAlways,
                mouseLocationYLocalAlways
            );
            if(d < SLICE_VERTEX_RADIUS)
            {
                sliceMode = SLICE_MODE_DRAG_LINE;

                for(let i = 0 ; i < 2 ; ++i)
                {
                    grabbaseVertices[i].x = sliceVertices[i].x;
                    grabbaseVertices[i].y = sliceVertices[i].y;
                }
                grabbaseX = mouseLocationXLocalAlways;
                grabbaseY = mouseLocationYLocalAlways;
            }
            else
            {
                sliceMode = SLICE_MODE_NEW;
    
                sliceVertices[0].x = sliceVertices[1].x = Clamp(mouseLocationXLocalAlways / uicanvas.width, 0, 1);
                sliceVertices[0].y = sliceVertices[1].y = Clamp(mouseLocationYLocalAlways / uicanvas.height, 0, 1);
                invokeRender();
            }
        }

        onSliceGraphUpdate();
    }
    else
    {
        sliceMode = SLICE_MODE_NONE;
    }
    if(sliceMode !== SLICE_MODE_NONE)
    {
        return;
    }

    down = true;
    updateMouseLocation(e);
});

// Direction
const DIAL_STEPS = 100.0;
$(".direction_dial").attr("value", DIAL_STEPS / 4).knob({
    'max' : DIAL_STEPS,
    'height' : 110,
    'fgColor' : "#2A2A2A",
    'change' : function (v) { 
        const clock = this.cv;
        const tick = (clock - DIAL_STEPS / 4.0);
        const radian = -tick / DIAL_STEPS * Math.PI * 2;
        angle = radian / (2.0 * Math.PI) * 360.0;
        if(angle <= -180.0) {
            angle += 360.0;
        }
        glu_directionX = Math.cos(radian);
        glu_directionY = Math.sin(radian);
        glsl.setUniform("u_direction", glu_directionX, glu_directionY);
        
        // move to free mode
        $('#fixed_direction').val("");
        $("#dial_container").css("opacity", 1.0);

        glu_direction_fixedX = 0;
        glu_direction_fixedY = 0;
        glsl.setUniform("u_direction_fixed", glu_direction_fixedX, glu_direction_fixedY);
    }
});

$("#fixed_direction").on("change", function(e){
    const value = this.value;
    if(value) {
        $("#dial_container").css("opacity", 0.3);
        glu_mouselocationX = canvas.width * 0.5;
        glu_mouselocationY = canvas.height * 0.5;
        glsl.setUniform("u_mouselocation", glu_mouselocationX , glu_mouselocationY);

        const L = Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height);
        if(value === "↘") {
            glu_direction_fixedX = canvas.height / L;
            glu_direction_fixedY = -canvas.width / L;
        }
        if(value === "↗") {
            glu_direction_fixedX = canvas.height / L;
            glu_direction_fixedY = canvas.width / L;
        }
        if(value === "↖") {
            glu_direction_fixedX = -canvas.height / L;
            glu_direction_fixedY = canvas.width / L;
        }
        if(value === "↙") {
            glu_direction_fixedX = -canvas.height / L;
            glu_direction_fixedY = -canvas.width / L;
        }
    } else {
        glu_direction_fixedX = 0;
        glu_direction_fixedY = 0;
        $("#dial_container").css("opacity", 1.0);
    }
    glsl.setUniform("u_direction_fixed", glu_direction_fixedX, glu_direction_fixedY);
    invokeRender();
});

// Border
$("#border").on("input", function(e){
    const value = this.value;
    glsl.setUniform("u_border", parseFloat(value));
    $("#borderlabel").text(value + "px");
});

// Border color
var hueb_border = new Huebee( '.border_color', {
  notation: 'hex',
  saturations: 2,
});
hueb_border.on( 'change', function( color, hue, sat, lum ) {
    const R = color.slice(1, 3);
    const G = color.slice(3, 5);
    const B = color.slice(5, 7);
    const r = parseInt(R, 16) / 255.0;
    const g = parseInt(G, 16) / 255.0;
    const b = parseInt(B, 16) / 255.0;
    glsl.setUniform("u_border_color", r, g, b);
});

$('#Label_L_override').on('input', function () {
    invokeRender();
});
$('#Label_R_override').on('input', function () {
    invokeRender();
});

$("#fontsize").on("input", function(e){
    const value = this.value;
    invokeRender();
    $("#fontsizelabel").text(value + "px");
});
// from URL Params
const url = new URL(location);
const fontsize = url.searchParams.get('fontsize');
if(fontsize) {
    $("#fontsize").val(fontsize);
    $("#fontsizelabel").text(fontsize + "px");
}

var hueb_font = new Huebee( '.font_color', {
  notation: 'hex',
  saturations: 2,
});
hueb_font.on( 'change', function( color, hue, sat, lum ) {
    const R = color.slice(1, 3);
    const G = color.slice(3, 5);
    const B = color.slice(5, 7);
    const r = parseInt(R, 16) / 255.0;
    const g = parseInt(G, 16) / 255.0;
    const b = parseInt(B, 16) / 255.0;
    invokeRender();
});

var hueb_Nan_Color = new Huebee( '.Nan_Color', {
  notation: 'hex',
  saturations: 2,
});
hueb_Nan_Color.on( 'change', function( color, hue, sat, lum ) {
    const R = color.slice(1, 3);
    const G = color.slice(3, 5);
    const B = color.slice(5, 7);
    const r = parseInt(R, 16) / 255.0;
    const g = parseInt(G, 16) / 255.0;
    const b = parseInt(B, 16) / 255.0;
    glsl.setUniform("u_Nan_Color", r, g, b);
});

var hueb_Inf_Color = new Huebee( '.Inf_Color', {
  notation: 'hex',
  saturations: 2,
});
hueb_Inf_Color.on( 'change', function( color, hue, sat, lum ) {
    const R = color.slice(1, 3);
    const G = color.slice(3, 5);
    const B = color.slice(5, 7);
    const r = parseInt(R, 16) / 255.0;
    const g = parseInt(G, 16) / 255.0;
    const b = parseInt(B, 16) / 255.0;
    glsl.setUniform("u_Inf_Color", r, g, b);
});

function didChangeDiffMode(value) {
    glsl.setUniform("u_diffmode", value ? 1.0 : 0.0);
    const op = value ? 1.0 : 0.3;
    $("#diffscalelabel").css("opacity", op);
    $("#diffscale").css("opacity", op);
}
// Border
$("#diffscale").on("input", function(e) {
    const value = this.value;
    const scale = parseFloat(value) / 100.0;
    glsl.setUniform("u_diffscale", scale);
    $("#diffscalelabel").text(value + " %");
});

// paste
function imagePaste(sampler, dataURL) {
    glsl.setUniform(sampler, null);
    glsl.setUniform(sampler, dataURL);

    const image = new Image();
    image.onload = function() {
        setCanvasSize( image.width, image.height );
    };
    image.src = dataURL;

    onTriggeredUpdateImage();
}

$('.PasteAreaL').pastableNonInputable();
$('.PasteAreaL').on('pasteImage', function(ev, data) {
    L_filename = "clipboard L";
    updatePlaceHolder();
    imagePaste("u_image_L", data.dataURL);
});
$('.PasteAreaR').pastableNonInputable();
$('.PasteAreaR').on('pasteImage', function(ev, data) {
    R_filename = "clipboard R";
    updatePlaceHolder();
    imagePaste("u_image_R", data.dataURL);
});

function didChangeLoupeMode(value) {
    glsl.setUniform("u_loupemode", value ? 1.0 : 0.0);
    const op = value ? 1.0 : 0.3;
    $("#loupeSizeLabel").css("opacity", op);
    $("#loupeSize").css("opacity", op);

    $("#loupeScaleLabel").css("opacity", op);
    $("#loupeScale").css("opacity", op);
}
function didChangePostProcess(value) {
    glsl.setUniform("u_postProcess", value ? 1.0 : 0.0);
    const op = value ? 1.0 : 0.3;
    $("#postScaleLabel").css("opacity", op);
    $("#postScale").css("opacity", op);
    $("#GammaSelect").css("opacity", op);
}

$("#loupeSize").on("input", function(e) {
    const value = this.value;
    const size = parseFloat(value);
    glsl.setUniform("u_loupeSize", size);
    $("#loupeSizeLabel").text(size + " px");
});
$("#loupeScale").on("input", function(e) {
    const value = this.value;
    const scale = parseFloat(value) / 100.0;
    glsl.setUniform("u_loupeScale", scale);
    $("#loupeScaleLabel").text(value + " %");
});

$("#postScale").on("input", function(e) {
    const value = this.value;
    const scale = parseFloat(value) / 100.0;
    glsl.setUniform("u_postScale", scale);
    $("#postScaleLabel").text(value + " %");
});
$("#GammaSelect").change(function() {
    let value = $(this).val();
    let label = $(this).find('option:selected').text();

    glsl.setUniform("u_ACEScgToSRGB", label === "ACEScg to sRGB" ? 1.0 : 0.0 );
    glsl.setUniform("u_postGamma", parseFloat(value));
});

// on save
function onSave() {
    compositecanvas.width = canvas.width;
    compositecanvas.height = canvas.height;
    const compositecanvasCtx = compositecanvas.getContext('2d');
    compositecanvasCtx.drawImage(canvas, 0, 0);
    compositecanvasCtx.drawImage(uicanvas, 0, 0);

    var imgdata = compositecanvas.toDataURL('image/png');
    saveAs(imgdata, "compare.png");
}
function onSaveAnimation() {
    isRecording = true;
    $('#REC').css('background-image', 'url(RecAct.svg)');
}

// function onDebug() {
//     glsl.setUniform("u_image_L", null);

//     let raw = new Uint8Array([
//         0, 0, 0, 255, 
//         255, 0, 0, 255,
//         0, 255, 0, 255,
//         0, 0, 255, 255]);
//     let rawf = new Float32Array([
//         0, 0, 0, 1.0, 
//         Math.random(), 0.5, 0, 1.0,
//         0, 1.0, 0.5, 1.0,
//         0.5, 0, 1.0, 1.0,
    
//         Math.random(), Math.random(), Math.random(), 1.0,
//         Math.random(), Math.random(), Math.random(), 1.0]
//     );
//     glsl.setUniform("u_image_L", { width:2, height:3, data:rawf });
// }

var dragoverHandler = function(e){
    e.preventDefault();
    $(this).addClass("dragover");

    let objectID = $(this).attr("id");
    if(objectID === "drop-zoneL")
    {
        glsl.setUniform("u_hilightL", HILIGHT_VALUE);
    }
    else if(objectID == "drop-zoneR")
    {
        glsl.setUniform("u_hilightR", HILIGHT_VALUE);
    }
};
$("#drop-zoneL").on("dragover", dragoverHandler);
$("#drop-zoneR").on("dragover", dragoverHandler);

var dragleaveHandler = function(e){
    e.preventDefault();
    $(this).removeClass("dragover");

    let objectID = $(this).attr("id");
    if(objectID === "drop-zoneL")
    {
        glsl.setUniform("u_hilightL", 0);
    }
    else if(objectID == "drop-zoneR")
    {
        glsl.setUniform("u_hilightR", 0);
    }
};
$("#drop-zoneL").on("dragleave", dragleaveHandler);
$("#drop-zoneR").on("dragleave", dragleaveHandler);

function rmExt(s) {
    return s.replace(/\.[^/.]+$/, "");
}
function updatePlaceHolder() {
    $('#Label_L_override').attr("placeholder", L_filename);
    $('#Label_R_override').attr("placeholder", R_filename);
}

class LayeredExrImage {
    constructor( exrImage ) {
        this.width = exrImage.width;
        this.height = exrImage.height;
        let channels = exrImage.channels();
        let hasRGB = channels.includes("R") && channels.includes("G") && channels.includes("B");

        this.colorChannels = {};
        if( hasRGB )
        {
            this.colorChannels["RGB"] = [exrImage.plane("R"), exrImage.plane("G"), exrImage.plane("B")];
        }

        let otherColorChannels = 
            channels
            .filter( c => c.includes('.') )
            .map( c => c.slice( 0, c.length - 2 ));
            otherColorChannels = Array.from(new Set(otherColorChannels));
        
        for( let i = 0 ; i < otherColorChannels.length ; i++ )
        {
            let ch = otherColorChannels[i];
            let r = exrImage.plane(ch + ".R") ?? exrImage.plane(ch + ".X");
            let g = exrImage.plane(ch + ".G") ?? exrImage.plane(ch + ".Y");
            let b = exrImage.plane(ch + ".B") ?? exrImage.plane(ch + ".Z");
            if( r && g && b )
            {
                this.colorChannels[ch] = [r, g, b];
            }
        }
    }
    isRGBOnly()
    {
        return this.colorChannels["RGB"] && Object.keys( this.colorChannels ).length == 1;
    }
    getDefaultLayer()
    {
        if( this.colorChannels["RGB"] )
        {
            return this.getLayer("RGB");
        }
        return this.getLayer( Object.keys( this.colorChannels )[0] );
    }
    getLayer( layer ) 
    {
        let rgb = this.colorChannels[layer];
        let nNan = 0;
        let nInf = 0;
        let r = rgb[0];
        let g = rgb[1];
        let b = rgb[2];
        let nPixels = this.width * this.height;
        let rgba = new Float32Array(nPixels * 4);
        for (let i = 0; i < nPixels; i++) {
            let rval = r[i];
            let gval = g[i];
            let bval = b[i];
            rgba[i * 4 + 0] = rval;
            rgba[i * 4 + 1] = gval;
            rgba[i * 4 + 2] = bval;
            rgba[i * 4 + 3] = 1.0;

            if(Number.isNaN(rval) || Number.isNaN(gval) || Number.isNaN(bval))
            {
                nNan++;
            }
            else if(Number.isFinite(rval) == false || Number.isFinite(gval) == false || Number.isFinite(bval) == false)
            {
                nInf++;
            }
        }

        // Layer
        return { 
            width: this.width,
            height: this.height,
            data:rgba ,
            nNan: nNan,
            nInf: nInf
        }
    }
}

function setLayer( layer, sampler, isLeft )
{
    glsl.setUniform( sampler, layer );
    let rgba = layer.data;
    let nNan = layer.nNan;
    let nInf = layer.nInf;

    setCanvasSize( layer.width, layer.height );
    
    if(isLeft)
    {
        $("#L_fpLabel").text(`L NaN: ${nNan}, Inf: ${nInf}`);
    }
    else
    {
        $("#R_fpLabel").text(`R NaN: ${nNan}, Inf: ${nInf}`);
    }

    onTriggeredUpdateImage();
}

$("#layerL").on("change", function(e) {
    const value = this.value;
    let layer = imageLayeredL.getLayer(value);
    setLayer( layer, "u_image_L", true );
});
$("#layerR").on("change", function(e) {
    const value = this.value;
    let layer = imageLayeredR.getLayer(value);
    setLayer( layer, "u_image_R", false );
});
function updateExrLayerUI()
{
    let newHidden = !( imageLayeredL || imageLayeredR );
    if( newHidden )
    {
        $('#layerview').hide();
    }
    else
    {
        $('#layerview').show();
    }
    let newHiddenL = imageLayeredL === null || imageLayeredL.isRGBOnly();
    let newHiddenR = imageLayeredR === null || imageLayeredR.isRGBOnly();
    $("#layerL").css('visibility', newHiddenL ? 'hidden' : 'visible' );
    $("#layerR").css('visibility', newHiddenR ? 'hidden' : 'visible' );

    invokeRender();
}

var handleDrop = function(file, sampler, isLeft) {
    if(isLeft) {
        L_filename = rmExt(file.name);
    } else {
        R_filename = rmExt(file.name);
    }
    updatePlaceHolder();

    let isExr = file.name.endsWith('.exr');

    if( isExr )
    {
        $.blockUI({ message: 'loading exr...' });
    }

    let reader = new FileReader();
    reader.onload = function(event) {
        glsl.setUniform(sampler, null);

        if(isExr)
        {
            window.loadExr( event.target.result, function(exrImage) {
                let layered = new LayeredExrImage( exrImage );

                // update option
                let layerOption = null;
                if( isLeft )
                {
                    imageLayeredL = layered;
                    layerOption = $('#layerL');
                }
                else
                {
                    imageLayeredR = layered;
                    layerOption = $('#layerR');
                }
                layerOption.empty();
                for( let key in layered.colorChannels ) {
                    layerOption.append(new Option( key, key));
                }
                updateExrLayerUI();

                let defaultLayer = layered.getDefaultLayer();
                setLayer( defaultLayer, sampler, isLeft );

                $.unblockUI();
            } );
        }
        else
        {
            glsl.setUniform(sampler, event.target.result);
            const image = new Image();
            image.onload = function() {
                setCanvasSize( image.width, image.height );
            };
            image.src = event.target.result;

            if( isLeft )
            {
                imageLayeredL = null;
            }
            else
            {
                imageLayeredR = null;
            }
            updateExrLayerUI();

            if(isLeft)
            {
                $("#L_fpLabel").text(``);
            }
            else
            {
                $("#R_fpLabel").text(``);
            }

            onTriggeredUpdateImage();
        }
    }
    
    if(isExr)
    {
        reader.readAsArrayBuffer(file);
    }
    else
    {
        reader.readAsDataURL(file);
    }
};
$("#drop-zoneL").on("drop", function(e) {
    e.preventDefault();
    $(this).removeClass("dragover");
    if(0 < e.originalEvent.dataTransfer.files.length)
    {
        handleDrop(e.originalEvent.dataTransfer.files[0], "u_image_L", true);
    }

    glsl.setUniform("u_hilightL", 0);
    glsl.setUniform("u_hilightR", 0);
});
$("#drop-zoneR").on("drop", function(e) {
    e.preventDefault();
    $(this).removeClass("dragover");
    if(0 < e.originalEvent.dataTransfer.files.length)
    {
        handleDrop(e.originalEvent.dataTransfer.files[0], "u_image_R", false);
    }

    glsl.setUniform("u_hilightL", 0);
    glsl.setUniform("u_hilightR", 0);
});

function sqr(x) { return x * x; }
function mouseBorder()
{
    const useFixed = 0.0 < (sqr(glu_direction_fixedX) + sqr(glu_direction_fixedY));
    let dirX = useFixed ? glu_direction_fixedX : glu_directionX;
    let dirY = useFixed ? glu_direction_fixedY : glu_directionY;
    let base = glu_mouselocationX * dirX + glu_mouselocationY * dirY;
    let x    = mouseLocationXLocalAlways * dirX + mouseLocationYLocalAlways * dirY;
    let border = x - base;
    return border; 
}


$(document).on('dragover drop', function (e) {
    // update location for drag and drop
    updateMouseLocation(e);

    // ignore drop outside of the drop area.
    e.stopPropagation();
    e.preventDefault();
    
    return false;
});

// Control hilight
$("#uicanvas").on('dragover', function (e) {
    let border = mouseBorder();
    // console.log(border);
    if(border < 0.0)
    {
        glsl.setUniform("u_hilightL", HILIGHT_VALUE);
        glsl.setUniform("u_hilightR", 0.0);
    }
    else
    {
        glsl.setUniform("u_hilightL", 0);
        glsl.setUniform("u_hilightR", HILIGHT_VALUE);
    }
    
    e.preventDefault();
});

$("#uicanvas").on('drop', function (e) {
    if(0 < e.originalEvent.dataTransfer.files.length)
    {
        let border = mouseBorder();
        if(border < 0.0)
        {
            handleDrop(e.originalEvent.dataTransfer.files[0], "u_image_L", true);
        }
        else
        {
            handleDrop(e.originalEvent.dataTransfer.files[0], "u_image_R", false);
        }
    }

    glsl.setUniform("u_hilightL", 0);
    glsl.setUniform("u_hilightR", 0);
    
    e.stopPropagation();
    e.preventDefault();
});
$("#uicanvas").on("dragleave", function (e) {
    glsl.setUniform("u_hilightL", 0);
    glsl.setUniform("u_hilightR", 0);
    updateMouseLocation(e);
});

$("#drop-zoneL").on("click", function(e) {
    const input = document.createElement('input');
    input.type = 'file';
    input.onchange = event => { 
        handleDrop(event.target.files[0], "u_image_L", true);
    };
    input.click();
});
$("#drop-zoneR").on("click", function(e) {
    const input = document.createElement('input');
    input.type = 'file';
    input.onchange = event => { 
        handleDrop(event.target.files[0], "u_image_R", false);
    };
    input.click();
});

// left to right, top to bottom
// o.r, o.g, o.b, o.a, xi, yi will be filled.
function sampleNearestNeighbor(image, u, v, o)
{
    const xi = Clamp( Math.floor(image.width * u), 0, image.width - 1);
    const yi = Clamp( Math.floor(image.height * v), 0, image.height - 1);
    const index = (yi * image.width + xi) * 4;
    o.r = image.data[index];
    o.g = image.data[index+1];
    o.b = image.data[index+2];
    o.a = image.data[index+3];
    o.xi = xi;
    o.yi = yi;
}
function downloadTextureAsFloat(image)
{
    // the image might have float array already.
    if( image.source.constructor == Float32Array )
    {
        return {
            width: image.width,
            height: image.height,
            data: image.source
        };
    }

    glsl.gl.pixelStorei(glsl.gl.UNPACK_FLIP_Y_WEBGL, true);

    // https://stackoverflow.com/questions/4702032/accessing-image-texture-data-texels-on-webgl
    // Create a framebuffer backed by the texture
    let framebuffer = glsl.gl.createFramebuffer();
    glsl.gl.bindFramebuffer(glsl.gl.FRAMEBUFFER, framebuffer);
    glsl.gl.framebufferTexture2D(glsl.gl.FRAMEBUFFER, glsl.gl.COLOR_ATTACHMENT0, glsl.gl.TEXTURE_2D, image.texture, 0);

    // Read the contents of the framebuffer (data stores the pixel data)
    let dataU8 = new Uint8Array(image.width * image.height * 4);
    glsl.gl.readPixels(0, 0, image.width, image.height, glsl.gl.RGBA, glsl.gl.UNSIGNED_BYTE, dataU8);

    glsl.gl.deleteFramebuffer(framebuffer);

    let dataF32 = new Float32Array(image.width * image.height * 4);
    
    // flip vertially and u8 to f32
    for(let y = 0 ; y < image.height ; ++y)
    {
        let y_dst = y;
        let y_src = image.height - 1 - y;
        for(let x = 0 ; x < image.width ; ++x)
        {
            let src_index = (y_src * image.width + x) * 4;
            let dst_index = (y_dst * image.width + x) * 4;
            for(let i = 0 ; i < 4 ; ++i)
            {
                dataF32[src_index + i] = dataU8[dst_index + i] / 255.0;
            }
        }
    }
    return {
        width: image.width,
        height: image.height,
        data: dataF32
    };
}
function onTriggeredUpdateImage()
{
    let u_image_L_Loading = glsl.textures["u_image_L"].loading;
    let u_image_R_Loading = glsl.textures["u_image_R"].loading;

    if( u_image_L_Loading !== null )
    {
        u_image_L_Loading.then( image => {
            imageLRaw = downloadTextureAsFloat(image);
            onSliceGraphUpdate();
        });
    }
    if( u_image_R_Loading !== null )
    {
        u_image_R_Loading.then( image => {
            imageRRaw = downloadTextureAsFloat(image);
            onSliceGraphUpdate();
        });
    }
}

// Run once for initialize
onTriggeredUpdateImage();

let plot = null;
let sliceGraphData = null;
function onSliceGraphUpdate()
{
    if(plot == null) { return; }
    if(isSliceGraphShowing == false) { return; }

    // build data
    let widthSlice = Math.abs(sliceVertices[0].x - sliceVertices[1].x) * canvas.width;
    let heightSlice = Math.abs(sliceVertices[0].y - sliceVertices[1].y) * canvas.height;
    let numSample = Math.floor(widthSlice + heightSlice);
    let distanceSlice = Math.sqrt(widthSlice * widthSlice + heightSlice * heightSlice);

    if( numSample < 5) { return; }

    sliceGraphData = [
        Array(numSample),

        Array(numSample),
        Array(numSample),
        Array(numSample),

        Array(numSample),
        Array(numSample),
        Array(numSample),
    ];
    let oL = {};
    let oR = {};
    for(let i = 0 ; i < numSample ; ++i)
    {
        let amt = i / (numSample - 1);
        let x = distanceSlice * amt;
        sliceGraphData[0][i] = x; // x axis

        let u = lerp(sliceVertices[0].x, sliceVertices[1].x, amt);
        let v = lerp(sliceVertices[0].y, sliceVertices[1].y, amt);

        function cleanF(x) {
            return Number.isFinite(x) ? x : null;
        }
        
        sampleNearestNeighbor(imageLRaw, u, 1.0 - v, oL);
        sliceGraphData[1][i] = cleanF(oL.r);
        sliceGraphData[2][i] = cleanF(oL.g);
        sliceGraphData[3][i] = cleanF(oL.b);

        sampleNearestNeighbor(imageRRaw, u, 1.0 - v, oR);
        sliceGraphData[4][i] = cleanF(oR.r);
        sliceGraphData[5][i] = cleanF(oR.g);
        sliceGraphData[6][i] = cleanF(oR.b);
    }

    let nSeries = plot.series.length;
    for(let i = 0 ; i < nSeries - 1 ; i++)
    {
        plot.delSeries( nSeries - 1 - i );
    }

    let lineDash = [5, 2];
    plot.addSeries({
        value: (self, rawValue) => rawValue.toFixed(3),
        label: "L",
        stroke: "#DD0000",
        dash: lineDash,
    }, 1);
    plot.addSeries({
        value: (self, rawValue) => rawValue.toFixed(3),
        label: "L",
        stroke: "#00DD00",
        dash: lineDash,
    }, 2);
    plot.addSeries({
        value: (self, rawValue) => rawValue.toFixed(3),
        label: "L",
        stroke: "#0000DD",
        dash: lineDash,
    }, 3);
    plot.addSeries({
        value: (self, rawValue) => rawValue.toFixed(3),
        label: "R",
        stroke: "red",
    }, 4);
    plot.addSeries({
        value: (self, rawValue) => rawValue.toFixed(3),
        label: "R",
        stroke: "green",
    }, 5);
    plot.addSeries({
        value: (self, rawValue) => rawValue.toFixed(3),
        label: "R",
        stroke: "blue",
    }, 6);

    plot.setData(sliceGraphData);
}

function makeChart( container ) {
    var loop = 1e4;

    let data = [
        Array(),
        Array(),
    ];

    for (var i = 0; i < loop; i++) {
        let x = 2 * Math.PI * i / loop;
        let y = Math.sin(x);

        data[0][i] = x;
        data[1][i] = y;
    }
    const opts = {
        width: 600,
        height: 400,
        plugins: [
        {
            hooks: {
                setCursor: u => {
                    const { left, top, idx } = u.cursor;
                    if( idx == null )
                    {
                        focusSliceAMT = null;
                    }
                    else
                    {
                        focusSliceAMT = idx / (u.data[0].length - 1);
                    }
                }
            }
        }],
        scales: {
            x: {
                time: false,
            },
            y: {
                auto: false,
                range: [0, 1],
            },
        },
        series: [
            {
                label: "x",
                value: (self, rawValue) => rawValue.toFixed(1),
            },
        ],
    };

    let u = new uPlot( opts, data, container );
    return u;
}
            
function onSliceGraph()
{
    let defaultWidth = 600;
    let defaultHeight = 300;
    $( "#sldialog" ).dialog({
        width: defaultWidth,
        height: defaultHeight,
       open: function (event) {
        //https://stackoverflow.com/questions/1619750/how-can-you-disable-scroll-bars-in-the-jquery-ui-dialog-box
        $('#sldialog').css('overflow', 'hidden'); //Hide Scroll Bar
        // doUpdateSLCanvas();
        isSliceGraphShowing = true;
        invokeRender();

        if( plot == null )
        {
            plot = makeChart( this );
        }
        let d = this;
        setTimeout(function() {
            onSliceGraphUpdate();
        }, 10);
        plot.setSize( {width: defaultWidth, height: defaultHeight - 10 /* fixbias*/ - 80} );

        $('#slicebutton').prop('disabled', true);
       },
       close: function (event) {
        isSliceGraphShowing = false;
        invokeRender();

        $('#slicebutton').prop('disabled', false);
       },
       resize: function( event, ui ) {
        plot.setSize( {width: ui.size.width, height: ui.size.height - 80} );
       },
    });
}
// setTimeout(function() {
//     onSliceGraph();
// }, 500);

</script>
</body>
</html>
